# Logic Bugs in IoT Platforms and Systems: A Review

CorpusID: 209516328 - [https://www.semanticscholar.org/paper/18311137888a74119a38efde68a5c9eaa0e56a2c](https://www.semanticscholar.org/paper/18311137888a74119a38efde68a5c9eaa0e56a2c)

Fields: Engineering, Computer Science

## (s23) Bug 11: Race Conditions of Events
(p23.0) A. Attack Scenario. As is defined in [5], an attribute of a device can not be modified to conflicting values by two or more noncomplementary event handlers of multiple apps working in concert, which may lead to a potential race condition. For example, "When motion is detected, turn on the switch" and "Every day at midnight, turn off the switch" will conflict if motion is detected at 12 pm. It is notable that the authors [5] do not investigate what attacks the adversary may realize by utilizing these bugs. Thus, the consequences caused by this bug are limited to leading devices trapped into insecure or unsafe states. * All the unexpected trigger-action bugs covered in this section lie in Samsung's Smart-Things Platform B. Cause Analysis. Upon its subscribed events' occurrence which is different from each other, two or more independent event-handlers of multiple apps are invoked to take actions possibly at the same time to manipulate the same attribute of one device to conflicting values. The sequence and timing of actions of these event-handlers usually make the final states of devices unpredictable.

(p23.1) C. Identifying Method.

(p23.2) The authors who discovered the above logic bug also proposed the identifying method named SOTERIA [5]. This approach translates the source code of an automation app into an intermediate representation (IR) at its initial phase. With the IR being fed into the second phase, a state model of the app including its states and transitions is constructed. For the third phase, a series of IoT properties are identified for further security analysis. Property S.4 states this race condition of events bug [5]. Model checking is performed to find the existence of property violations when the app functioning independently or working collectively with other apps. S.4 is violated during the interaction between multiple apps by invoking actions with different device events which manipulate the same attribute of the dedicated device to conflicting values [5].

(p23.3) D. Defense. IoTGuard [6] is a follow-up work that enforces a policy checker on a dedicated server. It is comprised of three components: a code instrumentor, a data collector, and security service. The code instrumentor provides two functions by adding extra logic to an app's source code. One is to collect runtime information including the app's actions, the event to trigger the action, the condition to be satisfied for the action, and the involved numerical-valued attributes, followed by sending the collected action's information to the data collector. The other one is to insert a guard, essentially waiting for a decision from the security service on the action to be taken.

(p23.4) The data collector receives all the action's information from the instrumented app when its event-handler gets invoked, which are loaded into the dynamic model. The design of this dynamic model is to emulate the logic of either an app execution not interacting with other apps or unified interaction of multiple apps before an action for further security service evaluation.
