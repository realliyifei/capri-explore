# A Survey of Semantics-Aware Performance Optimization for Data-Intensive Computing

CorpusID: 473793 - [https://www.semanticscholar.org/paper/0a87b1b2e089d8cf80b4b26cbb191f4648937732](https://www.semanticscholar.org/paper/0a87b1b2e089d8cf80b4b26cbb191f4648937732)

Fields: Engineering, Computer Science

## (s9) IV. PERFORMANCE DEFECTS
(p9.0) The availability of massive volume of data has led to the proliferation of data-intensive applications. The mainstream approach to scalability and expandability is to distribute data and computation to a large number of machines so that multiple processing nodes can work simultaneously. In order to process growing datasets efficiently, there exists a large body of techniques [16], [18], [19], [20], [24], [25], [32], [39], [52], [53], [57] that spans a variety wide of disciplines to improve data-intensive computing system performance. In this paper, we survey promising semantics-aware approaches to optimize the performance from the perspective of program analysis.
## (s11) B. Memory Management
(p11.0) In order to speed up development cycle and provide a friendly application interface, most data-intensive systems are developed in managed languages, such as C# and Java. Even though, there is an automatic memory management for some programming languages. Memory management in a data-intensive system is often prohibitively expensive. For instances, allocating and de-allocating a set of data objects would consume a huge of memory, which leads to poor performance of runtime system. In this scenario, systems could incur a high memory management overhead to allocate and release memory, and prolong the execution time. The computation on a worker node often suffers extensive memory pressure, i.e., the heap's limit is reached and more memory is required. Data-intensive applications may crash because of out-of-memory errors. The execution time can also be affected by garbage collection (GC), which is another challenging issue for performance optimization. In order to fix out or alleviate memory pressure, several memory optimization approaches have been proposed. FACADE [42] is a novel compiler framework, which tries to automatically transform data paths of an existing data-intensive application to generate highly-efficient data manipulation code. In FA-CADE, the number of runtime heap objects created for data types in each thread is (almost) statically bounded, which reduces memory management cost and improves scalability. In [41], a garbage collector called Yak is designed to provide high throughput and low latency for all JVM-based languages. In Yak, the management heap is divided into a control space (CS) and a data space (DS) based on the observation that there is a clear distinction between a control path and a data path in a typical data-intensive system.
## (s13) D. Data Analysis
(p13.0) In data-intensive computing, it is crucial to generate an efficient execution plan based on properties of code, data and platform. It may lead to a poor performance by using a fixed priori experience about these properties to determine execution plans, as most current platforms do. Moreover, it is difficult to extract and estimate these properties according to the highly distributed nature of data-intensive computing frameworks and the freedom that allows users to use UDF to represent a series of data operations. In [1], a framework, namely RoPE (Reoptimizer for Parallel Executions), is proposed to collect code and data properties by piggybacking on job execution. Then it determines execution plans by feeding these properties to a query optimizer component. In [27], a framework called MANIMAl automatically analyzes MapReduce programs and applies appropriate data-aware optimizations to the programs.
