# Survey of clustering algorithms for MANET

CorpusID: 945077 - [https://www.semanticscholar.org/paper/eb4656ba189aabc7b5f9fbc40a1aef6ec9f7da5a](https://www.semanticscholar.org/paper/eb4656ba189aabc7b5f9fbc40a1aef6ec9f7da5a)

Fields: Engineering, Computer Science

## (s2) Identifier-based clustering
(p2.0) A unique ID is assigned to each node. Nodes know the ID of its neighbors and clusterhead is chosen following some certain rules as given below. [1] is an algorithm in which a node with the minimum id is chosen as a clusterhead. Thus, the ids of the neighbors of the clusterhead will be higher than that of the clusterhead. A node is called a gateway if it lies within the transmission range of two or more clusterheads. Gateway nodes are generally used for routing between clusters. Each node is assigned a distinct id. Periodically, the node broadcasts the list of nodes that it can hear (including itself ).
## (s3) Lowest ID cluster algorithm (LIC)
(p3.0) • A node which only hears nodes with id higher than itself is a clusterhead. • The lowest-id node that a node hears is its clusterhead, unless the lowest-id specifically gives up its role as a clusterhead (deferring to a yet lower id node). • A node which can hear two or more clusterheads is a gateway. • Otherwise, a node is an ordinary node.

(p3.1) The Lowest-ID scheme concerns only with the lowest node ids which are arbitrarily assigned numbers without considering any other qualifications of a node for election as a clusterhead. Since the node ids do not change with time, those with smaller ids are more likely to become clusterheads than nodes with larger ids. Thus, drawback of lowest ID algorithm is that certain nodes are prone to power drainage due to serving as clusterheads for longer periods of time.

(p3.2) ISSN : 0975-3397 2.1.2 Max-Min d-cluster formation algorithm [2] generalizes the cluster definition to a collection of nodes that are up to d-hops away from a clusterhead. Due to the large number of nodes involved, it is desirable to let the nodes operate asynchronously. The clock synchronization overhead is avoided, providing additional processing savings. Furthermore, the number of messages sent from each node is limited to a multiple of d the maximum number of hops away from the nearest clusterhead, rather than n the number of nodes in the network. This guarantees a good controlled message complexity for the algorithm. Additionally, because d is an input value to the heuristic, there is control over the number of clusterheads elected or the density of clusterheads in the network. The amount of resources needed at each node is minimal, consisting of four simple rules and two data structures that maintain node information over 2d rounds of communication. Nodes are candidates to be clusterheads based on their node id rather than their degree of connectivity. As the network topology changes slightly the node's degree of connectivity is much more likely to change than the node's id relative to its neighboring nodes. If a node A is the largest in the d-neighborhood of another node B then node A, A will be elected a clusterhead, even though node A may not be the largest in its d-neighborhood. This provides a smooth exchange of clusterheads rather than an erratic exchange. This method minimizes the amount of data that must be passed from an outgoing clusterhead to a new clusterhead when there is an exchange. [1] The degree of a node is computed based on its distance from others. Each node broadcasts its id to the nodes that are within its transmission range. The node with maximum number of neighbors (i.e., maximum degree) is chosen as a clusterhead. The neighbors of a clusterhead become members of that cluster and can no longer participate in the election process. Since no clusterheads are directly linked, only one clusterhead is allowed per cluster. Any two nodes in a cluster are at most twohops away since the clusterhead is directly linked to each of its neighbors in the cluster. Basically, each node either becomes a clusterhead or remains an ordinary node.
## (s6) K-hop connectivity ID clustering algorithm (K-CONID)[3]
(p6.0) combines two clustering algorithms: the Lowest-ID and the Highest-degree heuristics. In order to select clusterheads connectivity is considered as a first criterion and lower ID as a secondary criterion. Using only node connectivity as a criterion causes numerous ties between nodes On the other hand, using only a lower ID criterion generates more clusters than necessary. The purpose is to minimize the number of clusters formed in the network and in this way obtain dominating sets of smaller sizes. Clusters in the K-CONID approach are formed by a clusterhead and all nodes that are at distance at most k-hops from the clusterhead.

(p6.1) At the beginning of the algorithm, a node starts a flooding process in which a clustering request is send to all other nodes. In the Highest-degree heuristic, node degree only measures connectivity for 1-hop clusters. K-CONID generalizes connectivity for a k-hop neighborhood. Thus, when k = 1 connectivity is the same as node degree.

(p6.2) Each node in the network is assigned a pair did = (d, ID). d is a node's connectivity and ID is the node's identifier. A node is selected as a clusterhead if it has the highest connectivity. In case of equal connectivity, a node has clusterhead priority if it has lowest ID. The basic idea is that every node broadcasts its clustering decision once all its k-hop neighbors with larger clusterhead priority have done so. [4]. In HCC clustering scheme, one cluster head can be exhausted when it serves too many mobile hosts. It is not desirable and the CH becomes a bottleneck. So a new approach [4] is given. In hello message format, there is an "Option" item. If a sender node is a cluster head, it will set the number of its dominated member nodes as "Option" value. When a sender node is not a cluster head or it is undecided (CH or non-CH), "Option" item will be reset to 0. When a CH's Hello message shows its dominated nodes' number exceeds a threshold (the maximum number one CH can manage), no new node will participate in this cluster. As a result, this can eliminate the CH bottleneck phenomenon and optimize the cluster structure. This algorithm can get load balance between various clusters. Thus, resource consumption and information transmission is distributed to all clusters instead of few clusters. [5] is a multihop clustering scheme with load-balancing capabilities. Each mobile node periodically broadcasts information about its ID, Clusterhead ID, and its status (clusterhead/member/gateway) to others within the same cluster. With the help of this broadcast, each mobile node obtains the topology information of its cluster. Each gateway also periodically exchanges information with neighboring gateways in different clusters and reports to its clusterhead. Thus, a clusterhead can know the number of mobile nodes of each neighboring cluster. Adaptive multihop clustering sets upper and lower bounds (U and L) on the number of clustermembers within a cluster that a clusterhead can handle.
## (s8) Adaptive multihop clustering
(p8.0) When the number of clustermembers in a cluster is less than the lower bound, the cluster needs to merge with one of the neighboring clusters. In order to merge two clusters into one cluster, a clusterhead always has to get the cluster size of all neighboring clusters. It prevents that the number of clustermembers in the merged cluster is over the upper bound. On the contrary, if the number of clustermembers in a cluster is greater than the upper bound, the cluster is divided into two clusters. However, Adaptive multihop clustering does not address how to select a proper node to serve as the clusterhead ISSN : 0975-3397 for the newly detached cluster. The upper and lower bounds are decided by network size, mobility etc. [6] partitions an ad hoc network into d-hop clusters based on mobility metric. The objective of forming d-hop clusters is to make the cluster diameter more flexible. This algorithm is based on mobility metric and the diameter of a cluster is adaptable with respect to node mobility. This clustering algorithm assumes that each node can measure its received signal strength. In this manner, a node can estimate its distance from its neighbors. Strong received signal strength implies closeness between two nodes. This algorithm requires the calculation of five terms: the estimated distance between nodes, the relative mobility between nodes, the variation of estimated distance over time, the local stability, and the estimated mean distance. Relative mobility corresponds to the difference of the estimated distance of one node with respect to another, at two successive time moments. This parameter indicates if two nodes move away from each other or if they become closer.
## (s10) Mobility-based d-hop clustering algorithm
(p10.0) The variation of estimated distances between two nodes is computed instead of calculating physical distance between two nodes. This is because physical distance between two nodes is not a precise measure of closeness. For instance, if a node runs out of energy it will transmit packets at low power acting as a distanced node from its physically close neighbor. The variation of estimated distance and the relative mobility between nodes are used to calculate the local stability. Local stability is computed in order to select some nodes as clusterheads. A node may become a clusterhead if it is found to be the most stable node among its neighborhood. Thus, the clusterhead will be the node with the lowest value of local stability among its neighbors. [7] proposes a local mobility metric for the cluster formation process such that mobile nodes with low speed relative to their neighbors have the chance to become clusterheads. By calculating the variance of a mobile node's speed relative to each of its neighbors, the aggregate local speed of a mobile node is estimated. A low variance value indicates that this mobile node is relatively less mobile to its neighbors. Consequently, mobile nodes with low variance values in their neighborhoods are chosen as clusterhead. For cluster maintenance, timer is used to reduce the clusterhead change rate by avoiding re-clustering for incidental contacts of two passing clusterheads. However, the mobility behavior of mobile nodes is not always considered in cluster maintenance, so a clusterhead is not guaranteed to bear a low mobility characteristic relative to its members during maintenance phase. As time advances, the mobility criterion is somewhat ignored. This scheme is effective for MANETs with group mobility behavior, in which a group of mobile nodes moves with similar speed and direction, as in highway traffic. Thus, a selected clusterhead can normally promise the low mobility with respect to its member nodes. However, if mobile nodes move randomly the performance may reduce.
## (s14) Least cluster change algorithm (LCC)
(p14.0) • When two clusterheads move into the reach range of each other, one gives up the clusterhead role. • When a mobile node cannot access any clusterhead, it rebuilds the cluster structure for the network according to LIC.

(p14.1) Hence, LCC significantly improves cluster stability by relinquishing the requirement that a clusterhead should HAVE some special features in its local area. But the second case of re-clustering in LCC indicates that a single node's movement may still invoke the complete cluster structure recomputation and thus results in large communication overhead. [10]. ensures small communication overhead for building clusters because each mobile node broadcasts only one message for the cluster construction. In this adaptive clustering scheme, every mobile node i keep its own ID and the ID of its direct neighbors in a set Gi. Each mobile node with the lowest ID in their local area declares to be a clusterhead and set its own ID as its cluster ID (CID). The CID information includes a mobile node's ID and CID. When a mobile node i receives CID information from a neighbor j, it deletes j from its set Gi. If the CID information from j is a clusterhead claim, the mobile node ISSN : 0975-3397 checks its own CID aspect. If its CID is unspecified (it is not involved in any cluster yet) or larger than the ID (CID) of j, it sets j as its clusterhead. The process continues till all mobile nodes access some cluster. After cluster formation is completed, clusterheads are no longer used in any further cluster maintenance phase. In the maintenance phase, when a mobile node i finds out that the distance between itself and some node j in the same cluster becomes greater than 2-hop, it invokes a cluster maintenance mechanism. If node i is a direct neighbor of the node with the highest intra-cluster connectivity in its cluster, it remains in the cluster and removes node j; otherwise, it joins a neighboring cluster. As soon as there is no proper cluster to join, it forms a new cluster to cover itself. Since this mechanism likely forms new clusters but without any cluster elimination or merge mechanisms, the cluster size decreases and the number of clusters increases as time advances. Eventually, almost every mobile node forms a single-node cluster, and the cluster structure disappears. [11]. This algorithm introduce a new node status, "clusterguest", which means this node is not within the transmission range of any clusterheads, but within the transmission range of some clustermembers. The cluster formation always begins from the neighborhood of the mobile node with the lowest ID (assuming it is mobile node mo) in a MANET. The mobile node with the highest node degree in mo's closed neighbor set is chosen to be the first clusterhead. All the direct neighbors of this clusterhead change status to "clustermember." After the completion of the first cluster, the cluster formation procedure can be performed in parallel in the network. A clustermember or a direct neighbor of any clustermember with status "unspecified" (indicating it is not included in any cluster yet) are denied serving as a clusterhead. A mobile node, which is not denied clusterhead capability, declares as a new clusterhead when it is with the highest node degree in its neighborhood. When a mobile node finds out that it cannot serve as a clusterhead or join a cluster as a clustermember, but some neighbor is a clustermember of some cluster, it joins the corresponding cluster as a clusterguest.
## (s22) Combined-weight based clustering
(p22.0) 2.6.1 Weighted clustering algorithm (WCA) [16] selects a clusterhead according to the number of nodes it can handle, mobility, transmission power and battery power. To avoid communications overhead, this algorithm is not periodic and the clusterhead election procedure is only invoked based on node mobility and when the current dominant set is incapable to cover all the nodes. To ensure that clusterheads will not be over-loaded a pre-defined threshold is used which indicates the number of nodes each clusterhead can ideally support. WCA selects the clusterheads according to the weight value of each node. The weight associated to a node v is defined as: Wv = w1 ∆v + w2 Dv +w3 Mv +w4 Pv ------------------------(1)

(p22.1) The node with the minimum weight is selected as a clusterhead. The weighting factors are chosen so that w1 + w2 + w3 + w4 = 1. Mv is the measure of mobility. It is taken by computing the running average speed of every node during a specified time T. ∆v is the degree difference. ∆v is obtained by first calculating the number of neighbors of each node. The result of this calculation is defined as the degree of a node v, dv. To ensure load balancing the degree difference ∆v is calculated as |dv -δ | for every node v, where δ is a pre-defined threshold. The parameter Dv is defined as the sum of distances from a given node to all its neighbors. This factor is related to energy consumption since more power is needed for larger distance communications. The parameter Pv is the cumulative time of a node being a clusterhead. Pv is a measure of how much battery power has been consumed. A clusterhead consumes more battery than an ordinary node because it has extra responsibilities.

(p22.2) The clusterhead election algorithm finishes once all the nodes become either a clusterhead or a member of a clusterhead. The distance between members of a clusterhead, must be less or equal to the transmission range between them. No two clusterheads can be immediate neighbors 2.6.2 Entropy-based Weighted clustering algorithm [17] In WCA high mobility of nodes leads to high frequency of reaffiliation which increase the network overhead. Higher reaffiliation frequency leads to more recalculations of the cluster assignment resulting in increase in communication overhead. Entropy based clustering overcomes the drawback of WCA and forms a more stable network. It uses an entropybased model for evaluating the route stability in ad hoc networks and electing clusterhead. Entropy presents uncertainty and is a measure of the disorder in a system. So it is a better indicator of the stability and mobility of the ad hoc network. [18] is based on two factors, neighbors' number and remaining battery time of every mobile host (MH) Each MH has a unique identifier (ID) number, which is a positive integer. The basic information inside the network is Hello message, which is transmitted in the common channel. Making use of node location information and power information, this algorithm introduce the concept of "vote". The Hello message format is given below. MH_ID item is MH's own ID and CH_ID item is MH's clusterhead ID, Vote item means MH's vote value, i.e. weighted sum of number of valid neighbors and remaining battery time. Option item is used to realize cluster load balance. Each MH sends a Hello message randomly during a Hello cycle. If a MH is a new user to the network, it reset "CH_ID" item. That means the MH does not belong to any cluster and does not know whether it has neighbor hosts. Each MH counts how many Hello messages it can receive during a Hello period, and considers the number of received Hello messages as its own n. Each MH sends another Hello message, in which "vote" item is set to its own vote value and got from Equation.
