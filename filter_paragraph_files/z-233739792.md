# Software Engineering for Blockchain Based Software Systems: Foundations, Survey, and Future Directions

CorpusID: 233739792 - [https://www.semanticscholar.org/paper/a0aa95edeeb2d8f836f1e92150dec5fab60788d8](https://www.semanticscholar.org/paper/a0aa95edeeb2d8f836f1e92150dec5fab60788d8)

Fields: Engineering, Computer Science

## (s4) Surveys on Engineering Internet-Based Computing Systems
(p4.0) Broadly-related surveys focus on intersections and synergies between Internet-based computing technologies such as blockchain, service computing, cloud computing, and IoTs. They are theoretically grounded on distributed architecture engineering that provides a backbone and virtually unlimited computational resources on-demand services to develop and deploy software systems. Surveys of Fahmideh et al., [9], [10], Lane et al., [28], and Razavian and Lago [29] are categorized under the broadly-related surveys. For example, cloud computing empowers the scalability and performance of blockchain platforms by providing service delivery models such as Infrastructure as a Service (IaaS), Software as a Service (SaaS), or Platform as a Service (PaaS). Fahmideh et al. in their initial work [30] that is later elaborated in [9] compare the characteristics of 43 reengineering approaches, published between 2007 and 2015, to make legacy software systems as cloud-enabled. Their survey synopsizes the status quo and presents a rich set of development tasks and recommendations commonly incorporated into typical migration processes to cloud platforms upon service delivery models such as IaaS, SaaS, or PaaS. Blockchain is used as an enabling technology for IoT-based applications as it provides a secured decentralized network for data management and communication of sensors and devices. Fahmideh and Zowghi [10] present a generic development process lifecycle for IoT-based applications by mapping 63 approaches, published between 2008 and 2019. They conclude that development roles, requirements analysis, modelling, testing, and tailorability of development processes are not addressed in the existing approaches to engineer IoT-based applications.

(p4.1) Razavian and Lago [29] present an analysis of reengineering processes in 75 approaches for developing SOA (serviceoriented architecture) based software applications. Their main contribution is to devise a new conceptual model and classifications of activities such as code analysis, architecture recovery, service design, and implementation in order to integrate with and componentize legacy applications to web services. They identify major challenges of (i) value creation for service-based software engineering, (ii) decision making on tool selection, and (iii) legacy understanding without reverseengineering.
## (s5) Surveys on Blockchain-based Systems Engineering
(p5.0) Scant work is available as being exclusively devoted to a review of existing proposals on the engineering of BBS. To support in-depth technical analysis, we discard introductory surveys that aimed at demystifying the notion of the blockchain and discussing prevailing challenges in adopting this technology in software applications and organizations. The reason is that they do not concentrate on the aspect of the development lifecycle and despite their usefulness in crafting our research objective, they fall outside the scope and focus of this survey. Some example surveys in this genre are the taxonomy-based surveys on the blockchain usage trend in the IoT context [34], consensus algorithms and application domains of blockchain [17], security concerns in blockchain adoption [35], [36], and business applications of blockchain [37]. The most extensive work is provided by Yli-Huumo et al., [38] with a research objective to understand the current research topics, challenges, and future directions regarding blockchain technology from the technical perspective, (page.1). By analyzing 41 primary studies, published between 2012 and 2015, where 80% of the papers focus on Bitcoin systems and less than 20% deal with other application domains, Yli-Huumo et al. highlight that the lack of concrete evaluation metrics and techniques to measure scalability efficiency in terms of throughput and latency is left unaddressed in the literature. The goal of the survey by Liu et al., [39] is to investigate the design of smart contracts, implementing trusted transactions among parties without mediators. They selected 53 papers to show the state-of-the-art of this topic, developed a taxonomy towards the security verification of blockchain smart contracts, and discussed the pros and cons of each category of the related studies.

(p5.1) None of the surveys in Table 1 is specifically geared towards the development lifecycle for BBS and intrinsic characteristics of blockchain that challenge well-established development processes of conventional software systems. As a response, we have narrowed our focus to extant studies that propose completely or partially, end-to-end approaches for BBS development. This includes development themes, essential tasks for incorporation into the development process, emerging roles, and modeling challenges. From this angle, our survey is more precise when compared to the related surveys. Our literature analysis is performed through a conceptual framework, encompassing four important dimensions of development approaches, processes, modeling, and roles that are not covered in related surveys. Our study aims to aid software teams, managers, and researchers in characterizing the extant material in the literature and mastering skills necessary to develop BBS. Due to the different focus and scope of our review, many research papers that we discuss in this survey are not covered by these existing surveys. For instance, none of the studies reviewed in our survey is covered by [39]. Our work supersedes the existing surveys as it considers many recently published studies in blockchain literature that are not included in any other surveys. 
## (s7) Systematic Literature Review
(p7.0) As stated earlier, this study aims to portray the current research landscape in software engineering for BBS. We formulated the following research questions:  [14] to conduct this SLR as they deem to be an appropriate way to systematically identify and qualitatively specify the criteria for the selected studies involved in the review and data synthesis. In the blockchain field, the concepts, nomenclature, and terminologies have not been consolidated yet. Hence, our SLR undertaking was not a linear and mechanical procedure. Instead, our review tended to be hermeneutic and iterative. That is, to get immersed in the literature, as recommended by Brun et al. [40], we read introductory and literature survey papers, some of which are listed in Section 3 (Table 1), to get an in-depth understanding of the important aspects of BBS engineering and further refinements of the literature review, in particular, inclusion/exclusion criteria definition and data extraction step. Our SLR's key steps included review protocol, searching queries, selection of study sources, study selection, data extraction, and data analysis as shown in Figure 2. More exactly, we determined the main terms software engineering, blockchain, and approach based on the research questions to define a set of search queries along with related abbreviations, plurals, and extended them with alternative synonyms. The approach was also used because some papers from our initial literature search used these terms to express frameworks and methods for the development of BBS. Search queries were executed against the main scientific digital libraries including Google Scholar, IEEE Explore, ACM Digital Library, Elsevier, SpringerLink, and ScienceDirect. We then selected papers that met the following inclusion criteria:

(p7.1)  explicitly discussed software engineering challenges related to BBS;  published in the software engineering and information systems international venues such as journals, conferences, congresses, and workshops as well as computing specific venues, e.g. computer networks and sensor-driven systems, that streamline software aspects of BBS;  written in English language with at least three pages (not an extended abstract, and  provided a proper validation of their work such as case study application, exemplar scenario, interview/survey of practitioners of blockchain practitioners, simulation, comparative analysis, or theoretical evaluation. Thus, based on the criterion above and standard SLR practice we discarded studies that were  opinions, white, and short papers without any sorts of evaluation results;  provide only background on blockchain or discussed the applications of blockchian in other enabling technologies like IoT, big data, and cloud computing;  Thesis or other non-refereed publications; and  Not written in English
## (s15) Ontology-based BBS development
(p15.0) Ontologies help reduce conceptual ambiguities and inconsistencies in a particular domain while enabling value-creation capabilities [60]. The application of ontologies becomes important to facilitate knowledge interoperability among stakeholders. Ontology-based system development is initiated by identifying concepts/classes in a domain, and followed by assigning properties for each concept and defining domain constraints and relationships among these concepts that need to be verified if constraints are violated by these properties [61]. In view of the identified studies, the purpose of ontology-based BBS development is for training [S41], identification, design, and test of smart contracts [S42],[S43], and improving discoverability of smart contract services at the run-time [S44]. Kruijff and Weigand [S41] discuss the support of ontologies for BBS development by providing essential concepts related to an operational BBS. Their proposed ontology can be viewed as a training material for software teams who might not be familiar with the key concepts of blockchain. This pioneering effort, in turn, has motivated others to explore alternative applications of ontologies to support the development activities of BBS, in particular the design phase, as will be delineated in Section 5.2.
## (s20) 5.2.3BBS implementation and test
(p20.0) The realization of the designed architecture in the previous phase is achieved via developing software and hardware components. According to the identified papers, a key aspect in conjunction with the implementation and test is the choice of blockchain platform. While tool support for the whole BBS lifecycle automation may not be feasible, the review of selected studies reveals several popular ones, either open-source or commercial, which are used during this phase for on-blockchain components. The example of these, as shown in Table 5 [62] is an open-source development platform, hosted by the Linux Foundation. It acts as enabling technologies to model and integrate existing systems with blockchain platforms. Hyperledger Fabric's programming model, supported by technologies Node.js and Java, enables more intuitive development in a plug-and-play fashion. An analytical comparison of features offered by these platforms is out of the scope of this survey. However, it has been a research query in the work by Bettín-Díaz et al.

(p20.1) [S18] synopsizing their experience in BBS engineering -with an application case in the supply chain. The authors recommend five key factors that software teams should investigate in their platform choice and, thereby, make an alignment between technical and managerial decisions. They are (i) maturity of the candidate blockchain platform in terms of how long it has been in the market, supporting model, and availability of documentation and training materials, (ii) ease of development which is based on required programming skills to work with the platform, (iii) confirmation time which depends on the choice of consensus mechanisms, (iv) security support between nodes as a platform may provide functionalities to enable public or private network configuration, and (vi) APIs support for functions related to audition, authentication, hash generating, data storage and retrieval, and smart contract lifecycle management. Furthermore, the literature suggests the use of mainstream tools and programming languages for coding, scripting, transferring/streaming, and data manipulation for offblockchain components. Testing is a key engineering task to ensure that an implemented BBS satisfies the specified requirements from the analysis phase. BBS testing that takes into account factors such as type of participants, permissions, input/output states, predefined trigger conditions and response actions of smart contracts, transactions, and expected outcomes in testing scenarios, is very much comparable to the conventional software engineering testing and can be performed at three levels: -unit testing that is to analyze each BBS component, for example, smart contract source code, to identify code segments prone to vulnerabilities during transaction execution and creating the chain of blocks; -integration testing that is to verify if on-blockchain and off-blockchain components work together correctly; and -user acceptance testing that is to validate the whole BBS. Baqa et al.

(p20.2) [S44] define a three-step strategy to conduct BBS testing: -test map creates a map of on-blockchain and off-blockchain components for which test is required; and -test plan specifies how each type of tests, such as unit and integration testing, should be performed within a planned number of test cases. For instance, for the performance test, software teams need to include parameters like measured execution time to record a transaction (time is spent to send a transaction request and receive confirmation from the receiver) and the time of cryptographic algorithm execution and consensus creation.

(p20.3) -test run performs test scenarios on a testnet, i.e. a testing environment, for example Bitcoin Testnet, allowing software teams to experiment BBS without worrying about real transactions or using bitcoins.

(p20.4) Conventional software engineering testing techniques such as code coverage review and stress testing may still have value and be applicable in BBS context, as acknowledged in [S1],[S44],[S52]. For example, a performance test principally is meant as the speed of adding a new block to the chain of blocks, and throughput of mining, consensus creation, and transaction validation. However, conventional software engineering testing practices appear to be insufficient on their own due to some intrinsic features of BBS. Testing smart contracts is crucial (Section 5.1 and 5.2.2). They are immutable and no one is supposed to tamper or change their source code once deployed and stored on a blockchain platform. Unlike conventional system development, further updates to fix identified bugs in smart contracts become an issue. Findings from a survey of 232 smart contract developers, conducted by Zou et al.

(p20.5) [S13], highlight the top testing challenges of smart contracts as (i) difficulty of identifying test scenarios, (ii) unpredictable flaws in blockchain platforms, virtual machines, and compilers, (iii) the lack of mature testing frameworks compared to well-established languages like C++ and Java, (iv) asynchronous environments of on-blockchain and off-blockchain, and (v) cost of gas consumption fee for testing smart contracts. Code review is a basic way to ensure the validity of a smart contract and, to this end, software teams can employ techniques such as (i) peer smart contract code review, (ii) requesting blockchain practitioners from GitHub community to check a smart contract, and (iii) asking third-party reviewers to audit smart contract code. Zou et al.

(p20.6) [S13], however, raise issues of code review including being time-consuming and difficult to find expert developers to identify security flaws in smart contracts. To lessen the complexity of code review, [S51] and [S52] similarly suggest three stages of testing in order to gradually identify and fix bugs in a smart contract code: (i) deploying contracts on a local network, (ii) deploying contracts on the test network for software team to use, and (iii) deploying contract on the live and main network and to execute them by users.
## (s30) Legacy system blockchain enablement is weakly supported
(p30.0) Usually, legacy software systems operating and storing critical data for years predate blockchain technology and the harness of distributed ledgers. Such legacy systems might have been implemented without taking into account the characteristics of computing platforms like blockchain. Software re-engineering process of these systems, allied to the large volume of organizational data, to make them blockchain-enabled is a crucial endeavor due to potential incompatibilities between blockchain and legacy platforms, mode of hosting, vendor-lock in, and security issues such as transparency and openness to participant nodes in blockchain network. Adopting reengineering approaches is important if large scale and complex transactions are intended to move from on-premise infrastructure to blockchain platforms. It is important to realize that whilst the term legacy system is often collocated with old technologies such as mainframes, monolithic architecture, file systems, communication protocols, and programming languages such as FORTRAN, COBOL, C, a BBS that has been developed using the latest blockchain platforms is subsumed under legacy if it is going to be moved to a new blockchain platform. According to this line of argument, a BBS migration from non-public Blockchain (e.g. Fabric9 and Quorum10) to public blockchain (e.g. Ethereum and NEO8), may raise issues such as APIs and data incompatibilities between platforms that should be organized and anticipated in a systematic way.

(p30.1) Whether or not the above perceptions is valid, it is worth investigating how and what new practices a software team should incorporate into the development process to make legacy system blockchain-enabled. A stream of research exists on legacy to SOA [29] and cloud [9], [30] and this can be timely to migrate legacy systems to blockchain platforms. The presented framework in this survey, in light of the reported findings in [S38], is a starting point to set the scene for further explanation.
