# A SURVEY ON DIFFERENCE HIERARCHIES OF REGULAR LANGUAGES

CorpusID: 4451760
 
tags: #Computer_Science, #Mathematics

URL: [https://www.semanticscholar.org/paper/a5de87b28d30e49ff8c8f16a7e808b8572c5c067](https://www.semanticscholar.org/paper/a5de87b28d30e49ff8c8f16a7e808b8572c5c067)
 
| Is Survey?        | Result          |
| ----------------- | --------------- |
| By Classifier     | False |
| By Annotator      | (Not Annotated) |

---

A SURVEY ON DIFFERENCE HIERARCHIES OF REGULAR LANGUAGES
2018

Olivier Carton olivier.carton@irif.fr 
ANDDominique Perrin dominique.perrin@esiee.fr 
Jean-Éric Pin jean-eric.pin@irif.fr 

Laboratoire d'informatique Gaspard-Monge
IRIF
CNRS
Université Paris-Diderot
Université de Marne-la-Vallée


IRIF, CNRS and Université Paris-Diderot


A SURVEY ON DIFFERENCE HIERARCHIES OF REGULAR LANGUAGES

Logical Methods in Computer Science
141201810.23638/LMCS-14(1:24)2018Submitted Feb. 28, 2017
Difference hierarchies were originally introduced by Hausdorff and they play an important role in descriptive set theory. In this survey paper, we study difference hierarchies of regular languages. The first sections describe standard techniques on difference hierarchies, mostly due to Hausdorff. We illustrate these techniques by giving decidability results on the difference hierarchies based on shuffle ideals, strongly cyclic regular languages and the polynomial closure of group languages.Dedicated to the memory of ZoltánÉsik.

Difference hierarchies were originally introduced by Hausdorff [12,13,14]. They play an important role in descriptive set theory [28,Section 11] and also yield a hierarchy on complexity classes known as the Boolean hierarchy [15,Section 3], [30,Section 2], [3], [2,Section 3]. Difference hierarchies were also used in the study of ω-regular languages [4,6,8,7,9,29].

The aim of this paper is to survey difference hierarchies of regular languages. Decidability questions for difference hierarchies over regular languages were studied in [10] and more recently by Glasser, Schmitz and Selivanov in [11]. The latter article is the reference paper on this topic and contains an extensive bibliography, to which we refer the interested reader. However, paper [11] focuses on forbidden patterns in automata, a rather different perspective than ours.

We first present some general results on difference hierarchies and their connection with closure operators. The results on approximation of Section 5, first presented in [5], lead in some cases to convenient algorithms to compute chain hierarchies.

Next we turn to algebraic methods. Indeed, a great deal of results on regular languages are obtained through an algebraic approach. Typically, combinatorial properties of regular languages -being star-free, piecewise testable, locally testable, etc. -translate directly to algebraic properties of the syntactic monoid of the language (see [18] for a survey). It is therefore natural to expect a similar algebraic approach when dealing with difference hierarchies. However, things are not that simple. First, one needs to work with ordered monoids, which are more appropriate for classes of regular languages not closed under complement. Secondly, although Proposition 7.3 yields a purely algebraic characterization of the difference hierarchy, it does not lead to decidability results, except for some special cases. Two such cases are presented at the end of the paper. The first one studies the difference hierarchy of the polynomial closure of a lattice of regular languages. The main result, Corollary 8.6, which appears to be new, states that the difference hierarchy induced by the polynomial of group languages is decidable. The second case, taken from [5], deals with cyclic and strongly cyclic regular languages.

Our paper is organised as follows. Prerequities are presented in Section 2. Section 3 covers the results of Hausdorff on difference hierarchies and Section 4 is a brief summary on closure operators. The results on approximation form the core of Section 5. Decidability questions on regular languages are introduced in Section 6. Section 7 on chains is inspired by results of descriptive set theory. Two results that are not addressed in [11] are presented in Sections 8 and 9. The final Section 10 opens up some perspectives.


## Prerequisites

In this section, we briefly recall the following notions: upper sets, ordered monoids, stamps and syntactic objects.

Let E be a preordered set. An upper set of E is a subset U of E such that the conditions x ∈ U and x y imply y ∈ U . An ordered monoid is a monoid M equipped with a partial order compatible with the product on M : for all x, y, z ∈ M , if x y then zx zy and xz yz.

A stamp is a surjective monoid morphism ϕ : A * → M from a finitely generated free monoid A * onto a finite monoid M . If M is an ordered monoid, ϕ is called an ordered stamp.

The restricted direct product of two stamps ϕ 1 : A * → M 1 and ϕ 2 : A * → M 2 is the stamp ϕ with domain A * defined by ϕ(a) = (ϕ 1 (a), ϕ 2 (a)). The image of ϕ is an [ordered] submonoid of the [ordered] monoid M 1 × M 2 . Stamps and ordered stamps are used to recognise languages. A language L of A * is recognised by a stamp ϕ : A * → M if there exists a subset P of M such that L = ϕ −1 (P ). It is recognised by an ordered stamp ϕ : A * → M if there exists an upper set U of M such that L = ϕ −1 (U ).

The syntactic preorder of a language was first introduced by Schützenberger in [26, p. 10]. Let L be a language of A * . The syntactic preorder of L is the relation L defined on A * by u L v if and only if, for every x, y ∈ A * , xuy ∈ L =⇒ xvy ∈ L.

The associated equivalence relation ∼ L , defined by u ∼ L v if u L v and v L u, is the syntactic congruence of L and the quotient monoid M (L) = A * /∼ L is the syntactic monoid of L. The natural morphism η :
A * → A * /∼ L is the syntactic stamp of L. The syntactic image of L is the set P = η(L).
The syntactic order P is defined on M (L) as follows: u P v if and only if for all x, y ∈ M (L), xuy ∈ P =⇒ xvy ∈ P The partial order P is stable and the resulting ordered monoid (M (L), P ) is called the syntactic ordered monoid of L. Note that P is now an upper set of (M (L), P ) and η becomes an ordered stamp, called the syntactic ordered stamp of L.


## Difference hierarchies

Let E be a set. In this article, a lattice is simply a collection of subsets of E containing ∅ and E and closed under taking finite unions and finite intersections. A lattice closed under complement is a Boolean algebra. Throughout this paper, we adopt Hausdorff's convention to denote union additively, set difference by a minus sign and intersection as a product. We also sometimes denote L c the complement of a subset L of a set E.

Let F be a set of subsets of E containing the empty set. We set B 0 (F) = {∅} and, for each integer n 1, we let B n (F) denote the class of all sets of the form
X = X 1 − X 2 + · · · ± X n (3.1)
where the sets X i are in F and satisfy X 1 ⊇ X 2 ⊇ X 3 ⊇ · · · ⊇ X n . By convention, the expression on the right hand side of (3.1) should be evaluated from left to right, but given the conditions on the X i 's, it can also be evaluated as
(X 1 − X 2 ) + (X 3 − X 4 ) + (X 5 − X 6 ) + · · · (3.2)
Since the empty set belongs to F, one has B n (F) ⊆ B n+1 (F) for all n 0 and the classes B n (F) define a hierarchy within the Boolean closure of F. Moreover, the following result, due to Hausdorff [13], holds:

Theorem 3.1. Let F be a lattice of subsets of E. The union of the classes B n (F) for n 0 is the Boolean closure of F.

Proof. Let B(F) = ∪ n 1 B n (F). By construction, every element of B n (F) is a Boolean combination of members of F and thus B(F) is contained in the Boolean closure of F. Moreover B 1 (F) = F and thus F ⊆ B(F). It is therefore enough to prove that B(F) is closed under complement and finite intersection. If X = X 1 − X 2 + · · · ± X n , one has
E − X = E − X 1 + X 2 − · · · ∓ X n
and thus X ∈ B(F) implies E − X ∈ B(F). Thus B(F) is closed under complement. Let X = X 1 − X 2 + · · · ± X n and Y = Y 1 − Y 2 + · · · ± Y m be two elements of B(F). Let
Z = Z 1 − Z 2 + · · · ± Z n+m−1 with Z k = i+j=k+1 i and j not both even X i Y j Therefore Z 1 = X 1 Y 1 , Z 2 = X 1 Y 2 + X 2 Y 1 , Z 3 = X 1 Y 3 + X 3 Y 1 , Z 4 = X 1 Y 4 + X 2 Y 3 + X 3 Y 2 + X 4 Y 1 ,
. . .
Z n+m−1 = X n Y m if m and n are not both even ∅ otherwise
We claim that Z = XY . To prove the claim, consider for each set X = X 1 − X 2 + · · · ± X n associated with the decreasing sequence X 1 , . . . , X n of subsets of E, the function µ X defined on E by µ X (x) = max {i 1 | x ∈ X i } with the convention that µ X (x) = 0 if x ∈ E − X 1 . Then x ∈ X if and only if µ X (x) is odd. We now evaluate µ Z (x) as a function of i = µ X (x) and j = µ Y (x). We first observe L 1 L 2 = {w ∈ A * | w = u 1 v 1 · · · u n v n for some words u 1 , . . . , u n , v 1 , . . . , v n of A * such that u 1 · · · u n ∈ L 1 and v 1 · · · v n ∈ L 2 } .

The shuffle product defines a commutative and associative operation over the set of languages over A. Given a language L, the language L A * is called the shuffle ideal generated by L and it is easy to see that the map L → L A * is a closure operator.

This closure operator can be extended to infinite words in two ways: the finite and infinite shuffle ideals generated by an ω-language X are respectively: X A * = {y 0 x 1 y 1 · · · x n y n x | y 0 , . . . , y n ∈ A * and x 1 · · · x n x ∈ X} X A ω = {y 0 x 1 y 1 x 2 · · · | y 0 , . . . , y n , · · · ∈ A * and x 1 x 2 · · · ∈ X} The maps X → X A * and X → X A ω are both closure operators.

Example 4.8. Ultimate closure. The ultimate closure of a language X of infinite words is defined by:

Ult(X) = {ux | u ∈ A * and vx ∈ X for some v ∈ A * } The map X → Ult(X) is a closure operator.


## Approximation

In this section, we consider a set F of closed sets of E containing the empty set. It follows that the corresponding closure operator satisfies the condition ∅ = ∅. We first define the notion of an approximation of a set by a chain of closed sets. Then the existence of a best approximation will be established. In this section, L is a subset of E.

Definition 5.1. A chain F 1 ⊇ F 2 ⊇ · · · ⊇ F n of closed sets is an n-approximation of L if the following inclusions hold for all k such that 2k + 1 n:
F 1 − F 2 ⊆ F 1 − F 2 + F 3 − F 4 ⊆ · · · ⊆ F 1 − F 2 + · · · + F 2k−1 − F 2k ⊆ · · · ⊆ L ⊆ · · · ⊆ F 1 − F 2 + F 3 − · · · + F 2k+1 ⊆ · · · ⊆ F 1 − F 2 + F 3 ⊆ F 1
There is a natural order among the n-approximations of a given set L. An n-approximation F 1 ⊇ F 2 ⊇ · · · ⊇ F n of L is said to be better than an n-approximation F 1 ⊇ F 2 ⊇ · · · ⊇ F n if, for all k such that 2k + 1 n,
F 1 − F 2 + F 3 − · · · + F 2k+1 ⊆ F 1 − F 2 + F 3 − · · · + F 2k+1 and F 1 − F 2 + · · · + F 2k−1 − F 2k ⊆ F 1 − F 2 + · · · + F 2k−1 − F 2k
We will need the following elementary lemma:
Lemma 5.2. Let X, Y and Z be subsets of E. (1) The conditions X − Y ⊆ Z and X − Z ⊆ Y are equivalent. (2) The conditions Z ⊆ X + Y and X c ∩ Z ⊆ Y are equivalent. (3) If Y ⊆ X and X − Y ⊆ Z, then X − Z = Y − Z and X + Z = Y + Z.
The description of the best approximation of L requires the introduction of two auxiliary functions. For every subset X of E, set f (X) = X − L and g(X) = X ∩ L (5.1)

The key properties of these functions are formulated in the following lemma.

Lemma 5.3. The following properties hold for all subsets X and Y of E:
(1) X − f (X) ⊆ L and L ⊆ X + g(X c ), (2) if X ⊇ Y ⊇ L, then f (X) ⊇ f (Y ) and X − f (X) ⊆ Y − f (Y ) ⊆ L, (3) if X ⊆ Y ⊆ L, then g(X) ⊆ g(Y ) and L ⊆ Y + g(Y c ) ⊆ X + g(X c ).
Proof. Let X and Y be subsets of E.

(1) follows from a simple computation:
X − f (X) = X − X − L ⊆ X − (X − L) = X ∩ L ⊆ L X + g(X c ) = X + X c ∩ L ⊇ (X ∩ L) + (X c ∩ L) = L. (2) Suppose that X ⊇ Y ⊇ L. Then X − L ⊇ Y − L and thus X − L ⊇ Y − L, that is, f (X) ⊇ f (Y ). Furthermore, X − Y ⊆ X − L ⊆ X − L = f (X). Applying part (3) of Lemma 5.2 with Z = f (X), one gets X − f (X) = Y − f (X), whence X − f (X) ⊆ Y − f (Y ) since f (X) ⊇ f (Y )
by the first part of (2).

(3) Suppose that X ⊆ Y ⊆ L. Then X ∩ L ⊆ Y ∩ L and thus g(X) ⊆ g(Y ). Furthermore,
Y − X = X c ∩ Y ⊆ X c ∩ L ⊆ X c ∩ L = g(X c ). Applying part (3) of Lemma 5.2 with Z = g(X c ), one gets Y + g(X c ) = X + g(X c ), whence Y + g(Y c ) ⊆ X + g(X c ) since g(Y c ) ⊆ g(X c )
by the first part of (3).

Lemma 5.4. Let F 1 ⊇ F 2 ⊇ · · · ⊇ F n be an n-approximation of L and, for 1 k n, let S k = F 1 − F 2 + · · · ± F k . Then, for 1 k n,
f (S k ) = f (F k ) if k is odd g(S c k ) = g(F k ) if k is even (5.2)
Proof. If k = 1, then S 1 = F 1 and the result is trivial. Suppose that k > 1. If k is odd,
S k−1 ⊆ L and thus S k − L = (S k−1 + F k ) − L = F k − L. It follows that f (S k ) = f (F k ). If k is even, L ⊆ S k−1 and thus S c k ∩ L = (S c k−1 + F k ) ∩ L = F k ∩ L. Therefore g(S c k ) = g(F k )
. Define a sequence (L n ) n 0 of subsets of E by L 0 = E and, for all n 0,
L n+1 = f (L n ) if n is odd g(L n ) if n is even (5.3)
The next theorem expresses the fact that the sequence (L n ) n 0 is the best approximation of L as a Boolean combination of closed sets. In particular, if L n = ∅ for some n > 0, then L ∈ B n−1 (F).

Theorem 5.5. Let L be a subset of E. For every n > 0, the sequence (L k ) 1 k n is the best n-approximation of L.

Proof. We first show that the sequence (L k ) 1 k n is an n-approximation of L. First, every L k is closed by construction. We show that L k+1 ⊆ L k by induction on k. This is true
for k = 0 since L 0 = E. Now, if k is even, L k+1 = L k ∩ L ⊆ L k = L k and if k is odd, L k+1 = L k − L ⊆ L k = L k . Set, for k > 0, S k = L 1 − L 2 + · · · ± L k . By part (1) of Lemma 5.3, the relations L 2k−1 − L 2k = L 2k−1 − f (L 2k−1 ) ⊆ L hold for every k > 0, and similarly, L 2k − L 2k+1 = L 2k − g(L 2k ) ⊆ L c . It follows that S 2k ⊆ L. Furthermore S c 2k+1 = (L 0 − L 1 ) + (L 2 − L 3 ) + · · · + (L 2k − L 2k+1 ) ⊆ L c and thus L ⊆ S 2k+1 .
We now show that the sequence (L k ) 1 k n is the best approximation of L. Let (L k ) 1 k n be another n-approximation of L. Set, for k > 0, S k = L 1 − L 2 + · · · ± L k . Then, by definition, L ⊆ L 1 and thus
S 1 = L 1 = L ⊆ L 1 = L 1 = S 1 . Let k > 0. Suppose by induction that S 2k−1 ⊆ S 2k−1 . We show successively that S 2k ⊆ S 2k and S 2k+1 ⊆ S 2k+1 .
By definition of an approximation,
S 2k = S 2k−1 − L 2k ⊆ L, and thus S 2k−1 − L ⊆ L 2k by part (1) of Lemma 5.2. It follows that f (S 2k−1 ) = S 2k−1 − L ⊆ L 2k = L 2k . Now, since S 2k−1 ⊇ S 2k−1 ⊇ L, one can apply part (2) of Lemma 5.3 to get S 2k = S 2k−1 − L 2k ⊆ S 2k−1 − f (S 2k−1 ) ⊆ S 2k−1 − f (S 2k−1 ). Moreover since f (S 2k−1 ) = f (L 2k−1 ) = L 2k by Lemma 5.4, one gets S 2k ⊆ S 2k−1 − f (S 2k−1 ) = S 2k−1 − L 2k = S 2k . Similarly, L ⊆ S 2k+1 = S 2k + L 2k+1 and hence (S 2k ) c ∩ L ⊆ L 2k+1 by part (2) of Lemma 5.2. It follows that g((S 2k ) c ) = (S 2k ) c ∩ L ⊆ L 2k+1 = L 2k+1 . Now, since S 2k ⊆ S 2k ⊆ L, one can apply part (3) of Lemma 5.3 to get S 2k + g(S c 2k ) ⊆ S 2k + g((S 2k ) c ) ⊆ S 2k + L 2k+1 = S 2k+1 . Moreover since the equalities g(S c 2k ) = g(L 2k ) = L 2k+1 hold by Lemma 5.4, one gets S 2k+1 = S 2k + L 2k+1 = S 2k + g(S c 2k ) ⊆ S 2k+1 . which concludes the proof.
When F is a set of subsets of E closed under arbitrary intersection, Theorem 5.5 provides a characterization of the classes B n (F).

Corollary 5.6. Let L be a subset of E and let F be a set of subsets of E closed under (possibly infinite) intersection and containing the empty set. Let (L k ) 1 k n be the best n-approximation of L with respect to F. Then L ∈ B n−1 (F) if and only if L n = ∅ and in this case
L = L 1 − L 2 + · · · ± L n−1 (5.4) Proof. If L ∈ B n−1 (F), then L = F 1 − F 2 + · · · ± F n−1 with F 1 , . . . , F n−1 ∈ F. Let F n = ∅.
Then the sequence (F k ) 1 k n is an n-approximation of L. Since (L k ) 1 k n is the best n-approximation of L, one has L = L 1 − L 2 + · · · ± L n−1 . Thus, with the notation of Lemma
5.4, f (L n−1 ) = f (L) = ∅ if n − 1 is odd g(L n−1 ) = g(L c ) = ∅ if n − 1 is even (5.5)
Therefore, L n = ∅ by (5.3). Conversely, suppose that L n = ∅. If n = 2k, then
(L 1 − L 2 ) + · · · + (L 2k−1 − L 2k ) ⊆ L ⊆ (L 1 − L 2 ) + · · · + (L 2k−3 − L 2k−2 ) + L 2k−1 If n = 2k + 1, then (L 1 − L 2 ) + · · · + (L 2k−1 − L 2k ) ⊆ L ⊆ (L 1 − L 2 ) + · · · + (L 2k−1 − L 2k ) + L 2k+1
In both cases, one gets L = L 1 − L 2 + · · · ± L n−1 and thus L ∈ B n−1 (F).

Let us illustrate this corollary by a concrete example.

Example 5.7. Let A = {a, b, c} and let L be the lattice of shuffle ideals. If L is the language {1, a, b, c, ab, bc, abc}, a straightforward computation gives
L 0 = A * L 1 = g(L 0 ) = A * (L 0 ∩ L) = A * L = A * L 2 = f (L 1 ) = A * (L 1 − L) = A * {aa, ac, ba, bb, ca, cb, cc} = A * − {1, a, b, c, ab, bc} L 3 = g(L 2 ) = A * (L 2 ∩ L) = A * abc L 4 = f (L 3 ) = A * (L 3 − L) = A * ((A * abc) − abc)
= A * {aabc, abac, abca, babc, abbc, abcb, cabc, acbc, abcc}
L 5 = g(L 4 ) = A * (L 4 ∩ L) = ∅ It follows that L = L 1 − L 2 + L 3 − L 4 and L ∈ B 4 (L), but L / ∈ B 3 (L).
It is also possible to use the approximation algorithm for a set L of subsets of E closed under (possibly infinite) union and containing the set E. In this case, the set
L c = {L c | L ∈ L}
is closed under (possibly infinite) intersection and contains the empty set. Consequently, the approximation algorithm can be applied to L c but it describes the difference hierarchy B n (L c ). To recover the difference hierarchy B n (L), the following algorithm can be used. First compute the best L c -approximation of even length of L and the best L c -approximation of odd length of L c , say
L = L c 1 − L c 2 + · · · ± L c n (5.6) L c = F c 1 − F c 2 + · · · ± F c m (5.7)
with n even, m odd, L i , F i ∈ L and L n and F m possibly empty to fill the parity requirements. Now L admits the following L-decompositions, where L 1 and F 1 are possibly empty (and consequently deleted):
L = L n − L n−1 + · · · ± L 1 (5.8) = F m − F m−1 + · · · ± F 1 (5.9)
It remains to take the shortest of the two expressions to get the best L-approximation of L.


## Decidability questions on regular languages

Given a lattice of regular languages L, four decidability questions arise: In other words, given a regular language L, Question 6.1 asks to decide whether L ∈ L, Question 6.2 whether L ∈ B(L) and Question 6.3 whether L ∈ B n (L). Question 6.4 asks whether one can one effectively compute the smallest n such that L ∈ B n (L), if it exists. Note that if Questions 6.2 and 6.3 are decidable, then so is Question 6.4. Indeed, given a language L, one first decides whether L belongs to B(L) by Question 6.2. If the answer is positive, this ensures that L belongs to B n (L) for some n and Question 6.3 allows one to find the smallest such n.

If the lattice L is finite, it is easy to solve the four questions in a positive way. In some cases, a simple application of Corollary 5.6 suffices to solve Question 6.3 immediately. One just needs to find the appropriate closure operator and to provide algorithms to compute the functions f (X) and g(X) defined by (5.1).

Example 6.5. Let L be the lattice generated by the languages of the form B * , where B ⊆ A. Then both L and B(L) are finite. It is known that a regular language belongs to L if and only if its syntactic ordered monoid is idempotent and commutative and satisfies the inequation 1 x for all x [20]. It belongs to B(L) if and only if its syntactic monoid is idempotent and commutative.

Finally, one can define a closure operator by setting L = B * , where B is the set of letters occurring in some word of L. For instance, let L = ({a, b, c} * − {b, c} * ) + ({a, b} * − a * ) + 1. This language belongs to B(L) and its minimal automaton is represented below: Applying the approximation algorithm of Section 5, one gets
L 0 = {a, b, c} * , L 1 = {b, c} * , L 2 = b * and L 3 = ∅ and thus L = {a, b, c} * − {b, c} * + b * is the best 3-approximation of L.
If the lattice is infinite, our four questions become usually much harder, but can still be solved in some particular cases. We will discuss this in Sections 8 and 9, but first present a powerful tool introduced in [5], chains in ordered monoids.


## Chains and difference hierarchies

Chains can be defined on any ordered set. We first give their definition, then establish a connection with difference hierarchies.

Definition 7.1. Let (E, ) be a partially ordered set and let X be a subset of E. A chain of E is a strictly increasing sequence
x 0 < x 1 < . . . < x m−1 of elements of E.
It is called an X-chain if x 0 is in X and the x i 's are alternatively elements of X and of its complement X c . The integer m is called the length of the chain. We let m(X) denote the maximal length of an X-chain.

There is a subtle connection between chains and difference hierarchies of regular languages. Let M be a finite ordered monoid and let ϕ : A * → M be a surjective monoid morphism.  Before starting the proof, let us clarify a delicate point. The condition L = ϕ −1 (P ) means that L is recognised by the monoid M . It does not mean that L is recognised by the ordered monoid M , a property which would require P to be an upper set. Proof. For each s ∈ M , let m(P, s) be the maximal length of a P -chain ending with s. Finally, let, for each k > 0,
Let L = {ϕ −1 (U ) | U isU k = {s ∈ M | m(P, s) k}
We claim that U k is an upper set of M . Indeed, if s ∈ U k , there exists a P -chain x 0 < x 1 < · · · < x r−1 = s of length r k. Let t be an element of M such that s t. If s and t are not simultaneously in P , then x 0 < x 1 < · · · < x r−1 < t is a P -chain of length r + 1 k.

Otherwise, x 0 < x 1 < · · · < x r−2 < t is a P -chain of length r k. Thus m(P, t) k, and t ∈ U k , proving the claim.

We now show that P = U 1 − U 2 + U 3 − U 4 · · · ± U n (7.1) First observe that s ∈ P if and only if m(P, s) is odd. Since m(P ) n, one has m(P, s) n for every s ∈ M and thus U n+1 = ∅. Formula (7.1) follows, since for each r 0,
{s ∈ M | m(P, s) = r} = U r − U r+1 .
Let, for 1 i n, L i = ϕ −1 (U i ). Since U i is an upper set, each L i belongs to L. Moreover, one gets from (7.1) the formula
L = L 1 − L 2 + L 3 · · · ± L n (7.2)
which shows that L ∈ B n (L).

We now establish a partial converse to Proposition 7.2. A lattice of regular languages is a set L of regular languages of A * containing ∅ and A * and closed under finite union and finite intersection. Proof. If L ∈ B n (L), then L = L 1 − L 2 + L 3 · · · ± L n with L 1 ⊇ L 2 ⊇ · · · ⊇ L n and L i ∈ L. Let η i : A * → (M i , i ) be the syntactic morphism of L i and let P i = η i (L i ). Then each P i is an upper set of M i and L i = η −1 i (P i ). Let η : A * → M be the restricted product of the stamps η i . Condition (1) is satisfied by construction.

Observe that if η(u) = (s 1 , . . . , s n ) is an element of M , the condition s i+1 ∈ P i+1 is equivalent to u ∈ L i+1 , and since L i+1 is a subset of L i , this condition also implies u ∈ L i and s i ∈ P i . Consequently, for each element s = (s 1 , . . . , s n ) of M , there exists a unique k ∈ {0, . . . , n} such that s 1 ∈ P 1 , . . . , s k ∈ P k , s k+1 / ∈ P k+1 , . . . , s n / ∈ P n This unique k is called the cut of s. Setting one gets, with the convention L n+1 = ∅ for n odd,
η −1 (P ) = k odd (L 1 ∩ · · · ∩ L k ) − L k+1 = k odd (L k − L k+1 ) = L (7.3)
which proves (2).

Let now x 0 < x 1 < · · · < x m−1 be a P -chain. Let, for 0 i m − 1, x i = (s i,1 , . . . , s i,n ) and let k i be the cut of x i . We claim that k i+1 > k i . Indeed, since x i < x i+1 , s i,k i i s i+1,k i and since P i is an upper set, s i,k i ∈ P i implies s i+1,k i ∈ P i+1 , which proves that k i+1 k i . But since x i and x i+1 are not simultaneously in P , their cuts must be different, which proves the claim. Since x 0 ∈ P , the cut of x 0 is odd, and in particular, non-zero. It follows that 0 < k 0 < k 1 < · · · < k m−1 and since the cuts are numbers between 0 and n, m n, which proves (3).

It is tempting to try to improve Therefore, if L is a regular language, the maximal length of an L-chain cannot be in general computed in the syntactic monoid of L. It follows that decidability questions on B n (L), as presented in Section 6 below, cannot in general be solved just by inspecting the syntactic monoid. An exceptional case where the syntactic monoid suffices is presented in the next section.


## The difference hierarchy of the polynomial closure of a lattice

A language L of A * is a marked product of the languages L 0 , L 1 , . . . , L n if L = L 0 a 1 L 1 · · · a n L n for some letters a 1 , . . . , a n of A. Given a set L of languages, the polynomial closure of L is the set of languages that are finite unions of marked products of languages of L. The polynomial closure of L is denoted Pol L and the Boolean closure of Pol L is denoted BPol L. Finally, let co-Pol L denote the set of complements of languages in Pol L. In this section, we are interested in the difference hierarchy induced by Pol L. We consider several examples. The syntactic characterization of piecewise testable languages follows from a much deeper result of Simon [27].


## Theorem 8.2. A language is piecewise testable if and only if its syntactic monoid is J -trivial.

Note that the closed sets of the closure operator X → X A * of Example 4.7 are exactly the shuffle ideals. It follows that for the lattice L of shuffle ideals, the four questions mentioned earlier have a positive answer. More precisely, the decidability of the membership problem for L and for B(L) follows from Proposition 8.1 and Theorem 8.2, respectively. The decidability of Question 6.3 (and hence of Question 6.4) follows from the approximation algorithm. See Example 5.7.


### Group languages.

Recall that a group language is a language whose syntactic monoid is a group, or, equivalently, is recognized by a finite deterministic automaton in which each letter defines a permutation of the set of states. According to the definition of a polynomial closure, a polynomial of group languages is a finite union of languages of the form L 0 a 1 L 1 · · · a k L k where a 1 , . . . , a k are letters and L 0 , . . . , L k are group languages.

Let d G be the metric on A * defined as follows:
r G (u, v) = min {|M | | M is a finite group that separates u and v} d G (u, v) = 2 −r G (u,v)
It is known that d G defines the so-called pro-group topology on A * . It is also known that the closure of a regular language for d G is again regular and can be effectively computed. This result was actually proved in two steps: it was first reduced to a group-theoretic conjecture in [22] and this conjecture became a theorem in [25]. Let G be the set of group languages on A * and let Pol G be the polynomial closure of G. We also let co-Pol G denote the set of complements of languages of Pol G. The following characterization of co-Pol G was given in [17]. Theorem 8.3. Let L be a regular language and let M be its syntactic ordered monoid. The following conditions are equivalent:

(1) L ∈ co-Pol G, (2) L is closed in the pro-group topology on A * ,

for all x ∈ M , x ω 1.

Theorem 8.3 shows that co-Pol G, and hence Pol G, is decidable. The corresponding result for BPol G has a long story, related in detail in [19], where several other characterizations can be found. We now study the difference hierarchy based on co-Pol G. Let F be the set of closed subsets for the pro-group topology. Proof. Theorem 8.3 shows that co-Pol G is a subset of F. It follows that any language of B n (co-Pol G) belongs to B n (F). Let now L be a regular language of B n (F) and let (L k ) 1 k n be the best n-approximation of L with respect to F. Corollary 5.6 shows that L ∈ B n (F) if and only if L n+1 = ∅. Moreover, in this case L = L 1 − L 2 + · · · ± L n . According to the algorithm described at the end of Section 5, the best n-approximation of L is obtained by alternating the two operations f (X) = X − L and g(X) = X ∩ L Now, as we have seen, the closure of a regular language for d G is regular. It follows that if X is regular, then both f (X) and g(X) are regular and closed. By Theorem 8.3, they both belong to co-Pol G. It follows that each L k belongs to co-Pol G and thus L ∈ B n (co-Pol G).

This leads to the following corollary:
Corollary 8.6. The difference hierarchy B n (co-Pol G) is decidable.
Proof. Let L be a regular language. Theorem 8.4 shows that one can effectively decide whether L ∈ BPol G. If this is the case, it remains to find the minimal n such that L ∈ B n (F). But Proposition 8.5 shows that L belongs to B n (co-Pol G) if and only if it belongs to B n (F). Moreover, since the closure of a regular language can be effectively computed, the best n-approximation of L with respect to F can be effectively computed. Now, Corollary 5.6 gives an algorithm to decide whether L ∈ B n (F).


## Cyclic and strongly cyclic regular languages

Cyclic and strongly cyclic regular languages are two classes of regular languages related to symbolic dynamic and first studied in [1]. It was shown in [5] that an appropriate notion of chains suffices to characterise the difference hierarchy based on the class of strongly cyclic regular languages. This contrasts with Section 7, in which the general results on chain did not lead to a full characterization of difference hierarchies.

Let A = (Q, A, ·) be a finite (possibly incomplete) deterministic automaton. A word u stabilises a subset P of Q if P ·u = P . Given a subset P of Q, let Stab(P ) be the set of all words that stabilise P . The language Stab(A) that stabilises A is by definition the set of all words which stabilise at least one nonempty subset of Q.  One can show that the set of strongly cyclic languages of A * forms a lattice of languages but is not closed under quotients. For instance, as shown in Example 9.2, the language L = (b + aa) * + (ab * a) * + a * is strongly cyclic, but Corollary 9.9 will show that its quotient b −1 L = (b + aa) * is not strongly cyclic, since aa ∈ (b + aa) * but a / ∈ (b + aa) * . We will also need the following characterization [1, Proposition 7]: Proposition 9.3. Let A = (Q, A, E) be a deterministic automaton. A word u belongs to Stab(A) if and only if there is some state q of A such that for every integer n, the transition q · u n exists.

Strongly cyclic languages admit the following syntactic characterization [1, Theorem 8]. As usual, s ω denotes the idempotent power of s, which exists and is unique in any finite monoid.

Proposition 9.4. Let L be a non-full regular language. The following conditions are equivalent:

(1) L is strongly cyclic, (2) there is a morphism ϕ from A * onto a finite monoid M with zero such that
L = ϕ −1 ({s ∈ M | s ω = 0}),
(3) the syntactic monoid M of L has a zero and the syntactic image of L is the set of all elements s ∈ M such that s ω = 0.

Proposition 9.4 leads to a simple syntactic characterization of strongly cyclic languages. Recall that a language of A * is nondense if there exists a word u ∈ A * such that L ∩ A * uA * = ∅.

Proposition 9.5. Let L be a regular language, let M be its syntactic monoid and let P be its syntactic image. Then L is strongly cyclic if and only if it satisfies the following conditions, for all u, x, v ∈ M :
(S 1 ) ux ω v ∈ P implies x ω ∈ P , (S 2 )
x ω ∈ P if and only if x ∈ P . Furthermore, if these conditions are satisfied and if L is not the full language, then L is nondense.

Proof. Let L be a strongly cyclic language, let M be its syntactic monoid and let P be its syntactic image. If L is the full language, then the conditions (S 1 ) and (S 2 ) are trivially satisfied. If L is not the full language, then Proposition 9.4 shows that M has a zero and that P = {s ∈ M | s ω = 0}. Observing that x ω = (x ω ) ω , one gets
x ∈ P ⇐⇒ x ω = 0 ⇐⇒ (x ω ) ω = 0 ⇐⇒ x ω ∈ P which proves (S 2 ). Similarly, one gets ux ω v ∈ P ⇐⇒ (ux ω v) ω = 0 =⇒ x ω = 0 ⇐⇒ x ∈ P which proves (S 1 ).
Conversely, suppose that L satisfies (S 1 ) and (S 2 ). If L is full, then L is strongly cyclic. Otherwise, let z / ∈ P . Then z ω / ∈ P by (S 1 ) and uz ω v / ∈ P for all u, v ∈ M by (S 2 ). This means that z is a zero of M and that 0 / ∈ P . By Proposition 9.4, it remains to prove that x ∈ P if and only if x ω = 0. First, if x ∈ P , then x ω ∈ P by (S 2 ) and since 0 / ∈ P , one has x ω = 0. Conversely, if x ω = 0, then ux ω v ∈ P for some u, v ∈ M , since x ω is not equivalent to 0 in the syntactic congruence of P . It follows that x ω ∈ P by (S 1 ) and x ∈ P by (S 2 ).

We turn now to cyclic languages. Definition 9.6. A subset of a monoid is said to be cyclic if it is closed under conjugation, power and root. That is, a subset P of a monoid M is cyclic if it satisfies the following conditions, for all u, v ∈ M and n > 0:

(C 1 ) u n ∈ P if and only if u ∈ P , (C 2 ) uv ∈ P if and only if vu ∈ P .

This definition applies in particular to the case of a language of A * .

Example 9.7. If A = {a, b}, the language b * and its complement A * aA * are cyclic.

One can show that regular cyclic languages are closed under inverses of morphisms and under Boolean operations but not under quotients. For instance, the language L = {abc, bca, cab} is cyclic, but its quotient a −1 L = {bc} is not cyclic. Thus regular cyclic languages do not form a variety of languages. However, they admit the following straightforward characterization in terms of monoids.

Proposition 9.8. Let L be a regular language of A * , let ϕ be a surjective morphism from A * to a finite monoid M recognising L and let P = ϕ(L). Then L is cyclic if and only if P is cyclic.

Corollary 9.9. Every strongly cyclic language is cyclic.

Proof. Let L be a strongly cyclic language, let M be its syntactic monoid and let P be its syntactic image. By Proposition 9.5, P satisfies (S 1 ) and (S 2 ). It suffices now to prove that it satisfies (C 2 ). The sequence of implications
xy ∈ P (S 2 )
⇐⇒ (xy) ω ∈ P ⇐⇒ (xy) ω (xy) ω ∈ P ⇐⇒ (xy) ω−1 xy(xy) ω−1 xy ∈ P ⇐⇒ ((xy) ω−1 x)(yx) ω y ∈ P
(S 1 ) =⇒ (yx) ω ∈ P (S 2 )
⇐⇒ yx ∈ P.

shows that xy ∈ P implies yx ∈ P and the opposite implication follows by symmetry.

Another result is worth mentioning: for any regular cyclic language, there is a least strongly cyclic language containing it [5, Theorem 2].

Proposition 9.10. Let L be a regular cyclic language of A * , let η : A * → M be its syntactic stamp and let P = η(L). There M has a zero and the language
L = η −1 ({s | s ω = 0}) if 0 / ∈ P , A * otherwise.
is the least strongly cyclic language containing L.

Proof. If 0 / ∈ P , then the language L is strongly cyclic by Proposition 9.4. Morevover, since L is cyclic, P is cyclic by Proposition 9.8. It follows that if s ∈ P , then s ω ∈ P and in particular s ω = 0. Consequently, L contains L.

It remains to prove that L is the least strongly cyclic language containing L. Let X be a strongly cyclic language containing L and let u be a word of L. Let A = (Q, A, E) be a deterministic automaton such that X = Stab(A). Setting s = η(u), one has s ω = 0 by definition of L. Consequently, η(s) n = 0 for every integer n and there are two words x n and y n such that x n u n y n belongs to L. By Proposition 9.3, there is a state q n of A such that the transition q n · x n u n y n is defined. The transition (q n · x n ) · u n is thus defined for every n and by Proposition 9.3 again, the word u belongs to X. Thus L ⊆ X as required.

Suppose now that 0 ∈ P and let z be a word of L such that η(z) = 0. Let X be a strongly cyclic language containing L. If X is not full, then X is nondense by Proposition 9.5 and there exists a word u ∈ A * such that A * uA * ∩ X = ∅. Since X contains L, one also gets A * uA * ∩ L = ∅ and in particular zu / ∈ L. But this yieds a contradiction, since η(zu) = η(z)η(u) = 0 ∈ P and thus zu ∈ η −1 (P ) = L. Thus the only strongly cyclic language containing L is A * . Proof. Suppose that L is strongly cyclic and let e, f be two idempotents of M such that e ∈ P and e J f . Let u, v ∈ M be such that e = uf v. Since f ω = f , one gets uf ω v ∈ P and thus f ∈ P by Condition (S 1 ) of Proposition 9.5.

In the opposite direction, suppose that for all idempotents e, f of M , the conditions e ∈ P and e J f imply f ∈ P . Since L is cyclic, it satisfies (C 1 ) and hence (S 2 ). We claim that it also satisfies (S 1 ). Indeed, ux ω v ∈ P implies (ux ω v) ω ∈ P by (S 2 ). Furthermore, since (ux ω v) ω J x ω , one also has x ω ∈ P , and finally x ∈ P by (S 2 ), which proves the claim.

The precise connection between cyclic and strongly cyclic languages was given in [1]. Theorem 9.12. A regular language is cyclic if and only if it is a Boolean combination of regular strongly cyclic languages. Theorem 9.12 motivates a detailed study of the difference hierarchy of the class S of strongly cyclic languages. This study relies on a careful analysis of the chains on the set of idempotents of a finite monoid, pre-ordered by the relation J . Definition 9.13. A P -chain of idempotents is a sequence (e 0 , e 1 , . . . , e m−1 ) of idempotents of M such that e 0 J e 1 J · · · J e m−1 e 0 ∈ P and, for 0 < i < m, e i ∈ P if and only if e i−1 / ∈ P . The integer m is the length of the P -chain of idempotents.

We let (M, P ) denote the maximal length of a P -chain of idempotents of M . We consider in particular the case where ϕ : A * → M is a stamp recognising a regular language L of A * and P = ϕ(L). The next theorem shows that in this case, (M, P ) does not depend on the choice of the stamp recognising L, but only depends on L.

Theorem 9.14. Let L be a regular language. Let ϕ : A * → M and ψ : A * → N be two stamps recognising L. If P = ϕ(L) and Q = ψ(L), then (M, P ) = (N, Q).

Proof. It is sufficient to prove the result when ϕ is the syntactic stamp of L. Since the morphism ψ is surjective, M is a quotient of N and there is a surjective morphism π : N → M such that π • ψ = ϕ. It follows that π(Q) = P and π −1 (P ) = Q.

(9.1)

We show that to any P -chain of idempotents in N , one can associate a Q-chain of idempotents of the same length in M and vice-versa. Let (e 0 , . . . , e m−1 ) be a Q-chain of idempotents in N and let f i = π(e i ) for 0 i m − 1. Since every monoid morphism preserves J , the relations (9.1) show that (f 0 , . . . , f m−1 ) is a P -chain of idempotents in M .

Let now (f 0 , . . . , f m−1 ) be a P -chain of idempotents in M . Since We first prove the following lemma which states that the function is subadditive with respect to the symmetric difference. Lemma 9.16. If X and Y are regular languages, then (X Y ) (X) + (Y ).
f i−1 J f i , there exist for 1 i m − 1 elements u i , v i of M such that u i f i v i = f i
Proof. Suppose that the languages X and Y are respectively recognised by the stamps ϕ : A * → M and ψ : A * → N . Let P and Q be the images of X and Y in M and N , so that X = ϕ −1 (P ) and Y = ψ −1 (Q). The language X Y is recognised by the restricted product of the stamps ϕ and ψ, say γ : A * → R, and the image of X Y in R is
T = R ∩ P × (N − Q) + (M − P ) × Q .
Let ((e 0 , f 0 ), . . . , (e m−1 , f m−1 )) be a T -chain of idempotents in R. Let us consider the set I (resp. J) of integers i for which exactly one of the idempotents e i−1 or e i (resp. f i−1 or f i ) belongs to P (resp. Q). Formally, we define the sets of integers I and J to be . . , j q } with i 1 < · · · < i p and j 1 < · · · < j q . Then p + q = m − 1.
I = {1 i m − 1 | e i−1 ∈ P ⇐⇒ e i ∈ P } J = {1 i m − 1 | f i−1 ∈ Q ⇐⇒ f i ∈ Q}
Since (e 0 , f 0 ) ∈ T , the conditions e 0 ∈ P and f 0 / ∈ Q are equivalent. By symmetry, suppose that e 0 ∈ P . Then f 0 / ∈ Q and thus f 1 ∈ Q. Furthermore, the definitions of I and J give e 0 ∈ P, e 1 ∈ P, . . . e i 1 −1 ∈ P, e i 1 / ∈ P, . . . e i 2 −1 / ∈ P, e i 2 ∈ P, . . .
f 0 / ∈ P, f 1 / ∈ P, . . . f j 1 −1 / ∈ P, f j 1 ∈ P, . . . f j 2 −1 ∈ P, f j 2 / ∈ P, . . .
Then the sequence (e 0 , e i 1 , . . . , e ip ) is a P -chain of idempotents in M and (f j 1 , . . . , f q ) is a Qchain of idempotents in N . Therefore p+1 (X), q (Y ) and m = p+1+q
(X)+ (Y ). Thus (X Y ) (X) + (Y ).
We can now complete the proof of Theorem 9.15.

Proof. Let η : A * → M be the syntactic stamp of L and let P = η(L). Let also E(M ) be the set of idempotents of M . If L ∈ B n (F), then L = L 1 · · · L n for some strongly cyclic languages L i . By Corollary 9.11, one has (L i ) = 1 for 1 i n and thus (L) n by Lemma 9. 16.

Suppose now that (L) n. For each idempotent e of M , let (e) denote the maximal length of a P -chain of idempotents ending with e. Then (e) (L) by definition. For each i > 0, let P i = {s ∈ M | (s ω ) i} and L i = η −1 (P i ) Let e, f ∈ E(M ). Since every idempotent e satisfies e ω = e, the conditions e ∈ P i and e J f imply f ∈ P i . It follows by Corollary 9.11 that the languages L i are strongly cyclic. We claim that P = P 1 − P 2 + P 3 − P 4 . . . ± P m (9.2) First observe that since L is cyclic, an element s of M belongs to P if and only if s ω belongs to P . Moreover, s ω ∈ P if and only if (s ω ) is odd. Since (P ) n, one has (s ω ) n for every s ∈ M and thus P n+1 = ∅. Formula (9.2) follows, since for each r 0, {s ∈ M | (s ω ) = r} = P r − P r+1 .

Moreover, one gets from (9.2) the formula L = L 1 − L 2 + L 3 . . . ± L n (9.3) which completes the proof of the theorem.

Theorem 9.15 can be used to give an another proof of Theorem 9.12. To get this result, we must prove that any cyclic language belongs to the class B n (S) for some integer n. By Theorem 9.15, it suffices to prove that the length of the P -chains of idempotents in a monoid recognising L is bounded. This is a consequence of the following proposition [5,Proposition 5]. Moreover, if e i−1 J e i , then by [16,Proposition 1.12], the idempotents e i−1 and e i are conjugate. That is, there exist two elements x and y of M such that xy = e k−1 and yx = e k . Since L is cyclic, P is also cyclic by Proposition 9.8 and (C 2 ) implies that e i−1 ∈ P if and only if e i ∈ P , which contradicts the definition of a P -chain of idempotents. It follows that the sequence (e 0 , . . . , e n−1 ) is a strict < J -chain and hence its length is bounded by the J -depth of M .

Example 9.18. Let L be the cyclic language (b + aa) * + (ab * a) * + a * − b * + 1. Its syntactic monoid is the monoid with zero presented by the relations bb = b, a 3 = a, baa = a 2 b, a 2 ba = ba, bab = 0. Its transition table and its J -class structure are represented below. The syntactic image of L is P = {1, a, a 2 , aba, a 2 b} and (aba, b, 1) is a maximal P -chain of idempotents. 


## Conclusion

Difference hierarchies of regular languages form an appealing measure of complexity. They can be studied from the viewpoint of descriptive set theory and automata theory [11] or from an algebraic perspective, as presented in this paper. It would be interesting to compare these two approaches. The results proposed by Glasser, Schmitz and Selivanov [11], together with our new result on group languages, give hope that more decidability results might be obtained in a near future. In particular, the recent progress on concatenation hierarchies [21,23,24], might lead to new decidability results for the difference hierarchies induced by the lower levels of the Straubing-Thérien hierarchy.

Let us conclude with an open problem:

Question 10.1. Does there exist a lattice of regular languages L and an integer n such that the membership problems for L and for B(L) are decidable, but is undecidable for B n (L)?

If the answer to Question 10.1 is positive, a more precise question can be raised:

Question 10.2. For each integer n, does there exist a lattice of regular languages L such that the membership problems for L, B(L) and B n (L) are decidable, but the membership problem for B n+1 (L) is undecidable?

## Figure 1 :
1Five subsets of E.

## Question 6. 1 .
1Is the membership problem for L decidable? Question 6.2. Is the membership problem for B(L) decidable? Question 6.3. For a given positive integer n, is the membership problem for B n (L) decidable? Question 6.4. Is the hierarchy B n (L) decidable?


an upper set of M } By definition, every language of L is recognised by the ordered monoid M .

## Proposition 7. 2 .
2If there exists a subset P of M such that L = ϕ −1 (P ) and m(P ) n, then L belongs to B n (L).

## Proposition 7. 3 .
3Let L be a lattice of regular languages. If a language L belongs to B n (L), then there exist an ordered stamp η : A * → M and a subset P of M satisfying the following conditions:(1) η is a restricted product of syntactic ordered stamps of members of L, (2) L = η −1 (P ), (3) m(P ) n.

## P
= {s ∈ M | the cut of s is odd} A SURVEY ON DIFFERENCE HIERARCHIES OF REGULAR LANGUAGES 13


Proposition 7.3 by taking for M the syntactic morphism of L and for ϕ the syntactic morphism of L. However, Example 5.7 ruins this hope. Indeed, let F = {1, a, b, c, ab, bc, abc} be the set of factors of the word abc. Then the syntactic monoid of L can be defined as the set F ∪ {0} equipped with the product defined by xy = xy if x, y and xy are all in F 0 otherwise Now the syntactic image of L is equal to F . It follows that M − F = {0} and thus, whatever order is taken on M , the length of a chain is bounded by 3. Nevertheless, if L is the lattice of shuffle ideals, then L does not belong to B 3 (L).

## 8. 1 .
1Shuffle ideals. If L = {∅, A * }, then Pol L is exactly the set of shuffle ideals considered in Examples 4.7 and 6.5 and BPol L is the class of piecewise testable languages. The following easy result was mentioned in[20].Proposition 8.1. A language is a shuffle ideal if and only if its syntactic ordered monoid M satisfies the inequation 1 x for all x ∈ M .

## Theorem 8. 4 .
4Let L be a regular language and let M be its syntactic monoid. The following conditions are equivalent:(1) L ∈ BPol G,(2)the submonoid generated by the idempotents of M is J -trivial, (3) for all idempotents e, f of M , the condition ef e = e implies ef = e = f e.

## Proposition 8. 5 .
5For each n 0, a regular language belongs to B n (co-Pol G) if and only if it belongs to B n (F).

## Definition 9. 1 .
1A language is strongly cyclic if it stabilises some finite deterministic automaton.Example 9.2. If A is the automaton represented in Figure 2, then Stab({1}) = (b + aa) * , Stab({2}) = (ab * a) * , Stab({1, 2}) = a * and Stab(A) = (b + aa) * + (ab * a) * + a * .

## Figure 2 :
2The automaton A.


Given a finite monoid M , the Green's preorder relation J defined on M by s J t if and only if s ∈ M tM , or equivalently, if there exists u, v ∈ M such that s = utv is a preorder on M . The associated equivalence relation J is defined by s J t if s J t and t J s, or equivalently, if M sM = M tM .Corollary 9.11. Let L be a regular cyclic language of A * , let η : A * → M be its syntactic stamp and let P = η(L). Then L is strongly cyclic if and only if for all idempotents e, f of M , the conditions e ∈ P and e J f imply f ∈ P .

## − 1 .
1Let us choose an idempotent e m−1 such that π(e m−1 ) = f m−1 and some elements s i and t i of N such that π(s i ) = u i and π(t i ) = v i . We now define a sequence of idempotents (e 0 , . . . , e m−1 ) of N by settinge m−2 = (s m−1 e m−1 t m−1 ) ω e m−3 = (s m−2 e m−2 t m−2 ) ω · · · e 0 = (s 1 e 1 t 1 ) ω By construction, e 0 J · · · J e m−1 and a straightforward induction shows that π(e i ) = f i for 0 i m − 1. Moreover the equalities (9.1) show that e i ∈ Q if and only if f i ∈ P . It follows that (e 0 , . . . , e m−1 ) is a Q-chain of idempotents of N and thus (M, P ) = (N, Q). Since the integers (M, P ) only depend on L and not on the choice of the recognising monoid, let us define (L) as (M, P ) where M [P ] is the syntactic monoid [image] of L. Note that by Corollary 9.11, a cyclic language L is strongly cyclic if and only if (L) = 1. This is a special case of the following stronger result [5, Theorem 4]. Theorem 9.15. Let L be a regular cyclic language. Then L ∈ B n (S) if and only if (L) n.


Since the sequence ((e 0 , f 0 ), . . . , (e m−1 , f m−1 )) is a T -chain in R, one has e 0 J . . . J e m−1 and f 0 J . . . J f m−1 . Moreover, every integer i between 1 and m − 1 belongs to exactly one of the sets I or J. Otherwise, the idempotents (e i−1 , f i−1 ) and (e i , f i ) of R would be either both in T or both out of T . Let I = {i 1 , . . . , i p } and J = {j 1 , .

## Proposition 9 . 17 .
917Let L be a regular cyclic language. Let ϕ : A * → M be a stamp recognising L and let P = ϕ(L). Then the length of any P -chain of idempotents is bounded by the J -depth of M . Proof. Let (e 0 , . . . , e n−1 ) be a P -chain of idempotents in M . Then by definition e 0 J . . . J e n−1 .
AcknowledgmentsThe authors would like to thank the anonymous referees, whose suggestions strongly improved the quality of this paper.
Cyclic languages and strongly cyclic languages. M.-P Béal, O Carton, C Reutenauer, STACS '96. 1046M.-P. Béal, O. Carton and C. Reutenauer, Cyclic languages and strongly cyclic languages, in STACS '96, pp. 49-59, Lect. Notes in Comput. Sci. vol. 1046, 1996.

The Boolean hierarchy. I. Structural properties. J.-Y Cai, T Gundermann, J Hartmanis, L A Hemachandra, V Sewelson, K Wagner, G Wechsung, SIAM J. Comput. 17J.-Y. Cai, T. Gundermann, J. Hartmanis, L. A. Hemachandra, V. Sewelson, K. Wagner and G. Wechsung, The Boolean hierarchy. I. Structural properties, SIAM J. Comput. 17,6 (1988), 1232-1252.

The Boolean hierarchy: hardware over NP. J.-Y Cai, L Hemachandra, Structure in complexity theory. Berkeley, Calif; BerlinSpringer223J.-Y. Cai and L. Hemachandra, The Boolean hierarchy: hardware over NP, in Structure in complexity theory (Berkeley, Calif., 1986), pp. 105-124, Lect. Notes in Comput. Sci. vol. 223, Springer, Berlin, 1986.

Chain automata. O Carton, Theoret. Comput. Sci. 161O. Carton, Chain automata, Theoret. Comput. Sci. 161 (1996), 191-203.

A hierarchy of cyclic languages. O Carton, R.A.I.R.O.-Informatique Théorique et Applications. 31O. Carton, A hierarchy of cyclic languages, R.A.I.R.O.-Informatique Théorique et Applications 31,4 (1997), 355-369.

Chains and superchains in ω-semigroups. O Carton, D Perrin, Semigroups, Automata and Languages, J. Almeida, G. Gomes and P. SilvaWorld ScientificO. Carton and D. Perrin, Chains and superchains in ω-semigroups, in Semigroups, Automata and Languages, J. Almeida, G. Gomes and P. Silva (eds.), pp. 17-28, World Scientific, 1994.

Chains and superchains for ω-rational sets, automata and semigroups. O Carton, D Perrin, Int. J. Alg. Comput. 7O. Carton and D. Perrin, Chains and superchains for ω-rational sets, automata and semigroups, Int. J. Alg. Comput. 7,7 (1997), 673-695.

The Wadge-Wagner hierarchy of ω-rational sets. O Carton, D Perrin, Automata, Languages and Programming. P. Degano, R. Gorrieri and A. Marchetti-SpaccamelaSpringer-Verlag1256O. Carton and D. Perrin, The Wadge-Wagner hierarchy of ω-rational sets, in Automata, Languages and Programming, P. Degano, R. Gorrieri and A. Marchetti-Spaccamela (eds.), pp. 17-35, Lect. Notes in Comput. Sci. vol. 1256, Springer-Verlag, 1997.

The Wagner hierarchy of ω-rational sets. O Carton, D Perrin, Int. J. Alg. Comput. 9O. Carton and D. Perrin, The Wagner hierarchy of ω-rational sets, Int. J. Alg. Comput. 9,5 (1999), 597-620.

The Boolean structure of dot-depth one. C Glasser, H Schmitz, 2nd Workshop on Descriptional Complexity of Automata, Grammars and Related Structures. London, ON6C. Glasser and H. Schmitz, The Boolean structure of dot-depth one, J. Autom. Lang. Comb. 6,4 (2001), 437-452. 2nd Workshop on Descriptional Complexity of Automata, Grammars and Related Structures (London, ON, 2000).

Efficient algorithms for membership in Boolean hierarchies of regular languages. C Glasser, H Schmitz, V Selivanov, Theoret. Comput. Sci. 646C. Glasser, H. Schmitz and V. Selivanov, Efficient algorithms for membership in Boolean hierarchies of regular languages, Theoret. Comput. Sci. 646 (2016), 86-108.

. F Hausdorff, Grundzüge der Mengenlehre. Mit 53 Figuren im Text. Veit & CompF. Hausdorff, Grundzüge der Mengenlehre. Mit 53 Figuren im Text., Leipzig: Veit & Comp., 1914.

Grundzüge der Mengenlehre. F Hausdorff, Chelsea Publishing CompanyNew York, N. Y.F. Hausdorff, Grundzüge der Mengenlehre, Chelsea Publishing Company, New York, N. Y., 1949.

F Hausdorff, Set theory. John R. Aumann, et al.New YorkChelsea Publishing CompanyF. Hausdorff, Set theory, Chelsea Publishing Company, New York, 1957. Translated by John R. Aumann, et al.

The difference and truth-table hierarchies for NP, RAIRO. J Köbler, U Schöning, K W Wagner, Inform. Théor. Appl. 21J. Köbler, U. Schöning and K. W. Wagner, The difference and truth-table hierarchies for NP, RAIRO Inform. Théor. Appl. 21,4 (1987), 419-435.

Varieties of Formal Languages. J.-E Pin, London and PlenumNew YorkJ.-E. Pin, Varieties of Formal Languages, North Oxford Academic, London and Plenum, New York, 1986.

Polynomial closure of group languages and open sets of the Hall topology. J.-E Pin, 21th ICALP. BerlinSpringer820J.-E. Pin, Polynomial closure of group languages and open sets of the Hall topology, in 21th ICALP, Berlin, 1994, pp. 424-435, Lect. Notes in Comput. Sci. n˚820, Springer.

Finite semigroups and recognizable languages : an introduction, in NATO Advanced Study Institute Semigroups, Formal Languages and Groups. J.-E Pin, J. FountainKluwer academic publishersJ.-E. Pin, Finite semigroups and recognizable languages : an introduction, in NATO Advanced Study Institute Semigroups, Formal Languages and Groups, J. Fountain (ed.), pp. 1-32, Kluwer academic publishers, 1995.

a success story, in NATO Advanced Study Institute Semigroups, Formal Languages and Groups. J.-E Pin, P G = Bg, J. FountainKluwer academic publishersJ.-E. Pin, P G = BG, a success story, in NATO Advanced Study Institute Semigroups, Formal Languages and Groups, J. Fountain (ed.), pp. 33-47, Kluwer academic publishers, 1995.

J.-E Pin, A variety theorem without complementation, Russian Mathematics (Iz. VUZ). J.-E. Pin, A variety theorem without complementation, Russian Mathematics (Iz. VUZ) 39 (1995), 80-90.

The Dot-Depth Hierarchy, 45 Years Later, in The Role of Theory in Computer Science -Essays Dedicated to. J.-É Pin, Janusz Brzozowski, S. Konstantinidis, N. Moreira, R. Reis and S. JeffreyJ.-É. Pin, The Dot-Depth Hierarchy, 45 Years Later, in The Role of Theory in Computer Science - Essays Dedicated to Janusz Brzozowski, S. Konstantinidis, N. Moreira, R. Reis and S. Jeffrey (eds.), pp. 177-202, Word Scientific, 2017.

J.-E Pin, C Reutenauer, A conjecture on the Hall topology for the free group. 23J.-E. Pin and C. Reutenauer, A conjecture on the Hall topology for the free group, Bull. London Math. Soc. 23 (1991), 356-362.

Separating Regular Languages with First-Order Logic. T Place, M Zeitoun, Logical Methods in Computer Science. 12T. Place and M. Zeitoun, Separating Regular Languages with First-Order Logic, Logical Methods in Computer Science 12,5 (2016), 1-30.

T Place, M Zeitoun, Computer Science -Theory and Applications: 12th International Computer Science Symposium in Russia. P. WeilKazan, RussiaSpringerConcatenation Hierarchies: New Bottle, Old WineT. Place and M. Zeitoun, Concatenation Hierarchies: New Bottle, Old Wine, in Computer Science - Theory and Applications: 12th International Computer Science Symposium in Russia, CSR 2017, Kazan, Russia, June 8-12, 2017, Proceedings, P. Weil (ed.), pp. 25-37, Springer, 2017.

On the profinite topology on a free group. L Ribes, P A Zalesskii, Bull. London Math. Soc. 25L. Ribes and P. A. Zalesskii, On the profinite topology on a free group, Bull. London Math. Soc. 25,1 (1993), 37-43.

Une théorie algébrique du codage, Séminaire Dubreil. M P Schützenberger, Algèbre et théorie des nombres 9. M. P. Schützenberger, Une théorie algébrique du codage, Séminaire Dubreil. Algèbre et théorie des nombres 9 (1955-1956), 1-24. http://eudml.org/doc/111094.

Piecewise testable events. I Simon, Proc. 2nd GI Conf., H. Brackage. 2nd GI Conf., H. BrackageBerlin, Heidelberg, New YorkSpringer Verlag33I. Simon, Piecewise testable events, in Proc. 2nd GI Conf., H. Brackage (ed.), pp. 214-222, Lecture Notes in Comp. Sci. vol. 33, Springer Verlag, Berlin, Heidelberg, New York, 1975.

Early investigations of the degrees of Borel sets. W W Wadge, Wadge degrees and projective ordinals. La Jolla, CAIIThe Cabal Seminar.W. W. Wadge, Early investigations of the degrees of Borel sets, in Wadge degrees and projective ordinals. The Cabal Seminar. Volume II, pp. 166-195, Lect. Notes Log. vol. 37, Assoc. Symbol. Logic, La Jolla, CA, 2012.

On ω-regular sets. K Wagner, Inform. and Control. 43K. Wagner, On ω-regular sets, Inform. and Control 43,2 (1979), 123-177.

This work is licensed under the Creative Commons Attribution License. G Wechsung, Fundamentals of computation theory (Cottbus, 1985). Berlin; San Francisco, CA 94105, USA; Berlin, GermanySpringer199Suite. or Eisenacher Strasse 2, 10777G. Wechsung, On the Boolean closure of NP, in Fundamentals of computation theory (Cottbus, 1985), pp. 485-493, Lect. Notes in Comput. Sci. vol. 199, Springer, Berlin, 1985. This work is licensed under the Creative Commons Attribution License. To view a copy of this license, visit https://creativecommons.org/licenses/by/4.0/ or send a letter to Creative Commons, 171 Second St, Suite 300, San Francisco, CA 94105, USA, or Eisenacher Strasse 2, 10777 Berlin, Germany