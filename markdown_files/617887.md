# Design of LDPC Codes: A Survey and New Results

CorpusID: 617887
 
tags: #Engineering, #Computer_Science

URL: [https://www.semanticscholar.org/paper/c86374e2c091311860fd8f8616f50cb4f02fa3fa](https://www.semanticscholar.org/paper/c86374e2c091311860fd8f8616f50cb4f02fa3fa)
 
| Is Survey?        | Result          |
| ----------------- | --------------- |
| By Classifier     | True |
| By Annotator      | (Not Annotated) |

---

Design of LDPC Codes: A Survey and New Results
SEPTEMBER 2006

Gianluigi Liva 
Shumei Song 
Lan Lan 
Yifei Zhang 
Shu Lin 
William E Ryan 
Design of LDPC Codes: A Survey and New Results

JOURNAL OF COMMUNICATIONS SOFTWARE AND SYSTEMS
23SEPTEMBER 2006191
This survey paper provides fundamentals in the design of LDPC codes. To provide a target for the code designer, we first summarize the EXIT chart technique for determining (near-)optimal degree distributions for LDPC code ensembles. We also demonstrate the simplicity of representing codes by protographs and how this naturally leads to quasi-cyclic LDPC codes. The EXIT chart technique is then extended to the special case of protograph-based LDPC codes. Next, we present several design approaches for LDPC codes which incorporate one or more accumulators, including quasi-cyclic accumulatorbased codes. The second half the paper then surveys several algebraic LDPC code design techniques. First, codes based on finite geometries are discussed and then codes whose designs are based on Reed-Solomon codes are covered. The algebraic designs lead to cyclic, quasi-cyclic, and structured codes. The masking technique for converting regular quasi-cyclic LDPC codes to irregular codes is also presented. Some of these results and codes have not been presented elsewhere. The paper focuses on the binary-input AWGN channel (BI-AWGNC). However, as discussed in the paper, good BI-AWGNC codes tend to be universally good across many channels. Alternatively, the reader may treat this paper as a starting point for extensions to more advanced channels. The paper concludes with a brief discussion of open problems.

## I. INTRODUCTION

The class of low-density parity-check (LDPC) codes represents the leading edge in modern channel coding. They have held the attention of coding theorists and practitioners in the past decade because of their near-capacity performance on a large variety of data transmission and storage channels and because their decoders can be implemented with manageable complexity. They were invented by Gallager in his 1960 doctoral dissertation [1] and were scarcely considered in the 35 years that followed. One notable exception is Tanner, who wrote an important paper in 1981 [2] which generalized LDPC codes and introduced a graphical representation of LDPC codes, now called Tanner graphs. Apparently independent of Gallager's work, LDPC codes were re-invented in the mid-1990's by MacKay, Luby, and others [3] [4][5] [6] who noticed the advantages of linear block codes which possess sparse (low-density) parity-check matrices.

This papers surveys the state-of-the-art in LDPC code design for binary-input channels while including a few new Manuscript  results as well. While it is tutorial in some aspects, it is not entirely a tutorial paper, and the reader is expected to be fairly versed on the topic of LDPC codes. Tutorial coverages of LDPC codes can be found in [7] [8]. The purpose of this paper is to give the reader a detailed overview of various LDPC code design approaches and also to point the reader to the literature. While our emphasis is on code design for the binary-input AWGN channel (BI-AWGNC), the results in [9][10] [11] [12] demonstrate that a LDPC code that is good on the BI-AWGNC tends to be universally good and can be expected to be good on most wireless, optical, and storage channels.

We favor code designs which are most appropriate for applications, by which we mean codes which have low-complexity encoding, good waterfall regions, and low error floors. Thus, we discuss quasi-cyclic (QC) codes because their encoders may be implemented by shift-register circuits [13]. We also discuss accumulator-based codes because low-complexity encoding is possible from their parity-check matrices, whether they are quasi-cyclic or not. The code classes discussed tend to be the ones (or related to the ones) used in applications or adopted for standards. Due to time and space limitations, we cannot provide a complete survey. The present survey is biased toward the expertise and interests of the authors.

Before a code can be designed, the code designer needs to know the design target. For this reason, Section II first briefly reviews the belief propagation decoder for LDPC codes and then presents the so-called extrinsic information transfer (EXIT) chart technique for this decoder. The EXIT chart technique allows one to obtain near-optimal parameters for LDPC code ensembles which guide the code designer. The EXIT technique is extended in Section III to the case of codes based on protographs. Section IV considers LDPC codes based on accumulators. The code types treated in that section are: repeat-accumulate, irregular repeat-accumulate, irregular repeat-accumulate-accumulate, generalized irregular repeat-accumulate, and accumulate-repeat-accumulate. That section also gives examples of quasi-cyclic code design using protograph (or base matrix) representations. Section V surveys the literature on cyclic and quasi-cyclic LDPC code design based on finite geometries. Section VI presents several LDPC code design techniques based on Reed-Solomon codes. Section VII presents the masking technique for converting regular QC codes to irregular QC codes to conform to prescribed code parameters. Section VIII contains some concluding remarks and some open problems.


## II. DESIGN VIA EXIT CHARTS

We start with an m × n low-density parity-check matrix H, which corresponds to a code with design rate (n − m)/n, 1845 
V 1 V 2 V 3 V n−1 V n . . .
. . . which could be less than the actual rate, R = k/n, where k is the number of information bits per codeword. H gives rise to a Tanner graph which has m check nodes, one for each row of H, and n variable nodes, one for each column of H.
C 1 C 2 C m
Considering the general case in which H has non-uniform row and column weight, the Tanner graph can be characterized by degree assignments {d v (i)} n i=1 and {d c (j)} m j=1 , where d v (i) is the degree of the i-th variable node and d c (j) is the degree of the j-th check node. Such a graph, depicted in Fig.  1, is representative of the iterative decoder, with each node representing a soft-in/soft-out processor (or node decoder).

We shall assume the BI-AWGNC in our description of the LDPC iterative decoder. In this model, a received channel sample y is given by y = x + w, where x = (−1) c ∈ {±1} is the bipolar representation of the transmitted code bit c ∈ {0, 1} and w is a white Gaussian noise sample distributed as η 0, σ 2 w , where σ 2 w = N 0 /2, following convention. The channel bit log-likelihood ratios (LLRs) are computed as
L ch = log p (x = +1 | y) p (x = −1 | y) = 2y σ 2 w .(1)
In one iteration of the conventional, flooding-schedule iterative decoder, the variable node decoders (VNDs) first process their input LLRs and send the computed outputs (messages) to each of their neighboring check node decoders (CNDs); then the CNDs process their input LLRs and send the computed outputs (messages) to each of their neighboring VNDs. More specifically, the message from the i-th VND to the j-th CND is
L i→j = L ch,i + j =j L j →i(2)
where L j →i is the incoming message from CND j to VND i and where the summation is over the d v (i) − 1 check node neighbors of variable node i, excluding check node j. The message from CND j to VND i is given by
L j→i = 2 tanh −1 i =i tanh (L i →j )(3)
where L i →j is the incoming message from VND i to CND j and where the product is over the d c (j) − 1 variable node neighbors of check node j, excluding variable node i . This decoding algorithm is called the sum-product algorithm (SPA).

We now discuss the EXIT chart technique [14][15] [11] for this decoder and channel model. The idea is that the VNDs and the CNDs work cooperatively and iteratively to make bit decisions, with the metric of interest generally improving with each half-iteration. A transfer curve which plots the input metric versus the output metric can be obtained for both the VNDs and the CNDs, where the transfer curve for the VNDs depends on the channel SNR. Further, since the output metric for one processor is the input metric for its companion processor, one can plot both transfer curves on the same axes, but with the abscissa and ordinate reversed for one processor. Such a chart aids in the prediction of the decoding threshold of the ensemble of codes characterized by given VN and CN degree distributions: the decoding threshold is the SNR at which the two transfer curves just touch, precluding convergence of the two processors. EXIT chart computations are thus integral to the optimization of Tanner graph node degree distributions for LDPC codes and are the main computation in the optimization process. We emphasize that decoding threshold prediction techniques such as EXIT charts or density evolution [16] assume a graph with no cycles, an infinite codeword length, and an infinite number of decoding iterations.

An EXIT chart example is depicted in Fig. 2 for the ensemble of regular LDPC codes on the BI-AWGNC with d v (i) = d v = 3 for i = 1, ..., n, and d c (j) = d c = 6 for j = 1, ..., m. In the figure, the metric used for the transfer curves is extrinsic mutual information, giving rise to the name extrinsic information transfer (EXIT) chart. (The notation used in the figure is explained below.) Also shown in the figure is the decoding trajectory corresponding to these EXIT curves. As the SNR increases, the top curve shifts upwards, increasing the "tunnel" between the two curves and thus the decoder convergence rate. The SNR for this figure is just above the decoding threshold for codes with (d v , d c ) = (3, 6), (E b /N 0 ) thres = 1.1 dB. Other metrics, such as SNR and mean [17] [18] and error probability [19] are possible, but mutual information generally gives the most accurate prediction of the decoding threshold [14] [20] and is a universally good metric across many channels [9][10] [11] [12].

To facilitate EXIT chart computations, the following Gaussian assumption is made. First, we note that the LLR L ch in (1) corresponding to the BI-AWGNC is Gaussian with mean µ ch = 2x/σ 2 w and variance σ 2 ch = 4/σ 2 w . From this and the usual assumption that the all-zeros codeword was transmitted (thus, x i = +1 for i = 1, ..., n), σ 2 ch = 2µ ch . This is equivalent to the symmetric condition of [16] which states that the conditional pdf of an LLR value L must satisfy p L (l | x) = p L (−l | x) e xl . Now, it has been observed that under normal operating conditions and after a few iterations, the LLRs L i→j and L j→i are approximately Gaussian and, further, if they are assumed to be symmetric-Gaussian, as is the case for L ch , the decoding threshold predictions are very accurate (e.g., when compared to the more accurate, but more computationally intensive density evolution results [16]). Moreover, the symmetric-Gaussian assumption vastly simplifies EXIT chart analyses.

We now consider the computation of EXIT transfer curves  for both VNDs and the CNDs, first for regular LDPC codes and then for irregular codes. Following [14] [15], excluding the inputs from the channel, we consider VND and CND inputs to be a priori information, designated by 'A', and their outputs to be extrinsic information, designated by 'E'. Thus, an extrinsic information transfer curve for the VNDs plots the extrinsic information I E as a function of its input a priori information, I A , and similarly for the CNDs.

The VND EXIT curve, I E,V versus I A,V , under the symmetric-Gaussian assumption for VND inputs, L ch,i and {L j →i }, and outputs, L i→j , can be obtained as follows. From (2) and an independent-message assumption, L i→j is Gaussian with variance σ 2 = σ 2 ch + (d v − 1) σ 2 A (hence, mean σ 2 /2). The mutual information between the random variable X (corresponding to the realization x i ) and the extrinsic LLR L i→j is therefore (for simplicity, we write L for L i→j , x for x i , and p L (l | ±) for p L (l | x = ±1))
I E,V = H(X) − H(X | L) = 1 − E log 2 1/p X | L (x | l) = 1 − x=±1 1 2 ∞ −∞ p L (l | x) · log 2 p L (l | +) + p L (l | −) p L (l | x) dl = 1 − ∞ −∞ p L (l | +) log 1 + p L (l | −) p L (l | +) dl = 1 − ∞ −∞ p L (l | +) log 1 + e −l dl
where the last line follows from the symmetry condition and because p L (l | x = −1) = p L (−l | x = +1) for Gaussian densities.

Since L i→j ∼ η σ 2 /2, σ 2 (when conditioned on x i = +1), we have
I E,V = 1 − ∞ −∞ 1 √ 2πσ e −(l−σ 2 /2) 2 /2σ 2 log 1 + e −l dl .(4)
For convenience we write this as
I E,V = J (σ) = J (d v − 1) σ 2 A + σ 2 ch ,(5)
following [15]. To plot I E,V versus I A,V , where I A,V is the mutual information between the VND inputs L j→i and the channel bits x i , we apply the symmetric-Gaussian assumption to these inputs so that
I A,V = J (σ A )(6)
and
I E,V = J (σ) = J (d v − 1) [J −1 (I A,V )] 2 + σ 2 ch .(7)
The inverse function
J −1 (·) exists since J (σ A ) is monotonic in σ A . Lastly, I E,V can be parameterized by E b /N 0 for a given code rate R since σ 2 ch = 4/σ 2 w = 8R (E b /N 0 )
. Approximations of the functions J (·) and J −1 (·) are given in [15].

To obtain the CND EXIT curve, I E,C versus I A,C , we can proceed as we did in the VND case, e.g., begin with the symmetric-Gaussian assumption. However, this assumption is not sufficient because determining the mean and variance for a CND output L j→i is not straightforward, as is evident from the computation for CNDs in (3). Closed-form expressions have been derived for the check node EXIT curves [21] [22]. Computer-based numerical techniques can also be used to obtain these curves. However, the simplest technique exploits the following duality relationship (proven to be exact for the binary erasure channel [11]): the EXIT curve for a degree-d c check node (i.e., rate-(d c − 1)/d c single-parity check (SPC) code) and that of a degree-d c variable node (i.e., rate-1/d c repetition code) are related as
I E,SP C (d c , I A ) = 1 − I E,REP (d c , 1 − I A ) .
This relationship was shown to be very accurate for the BI-AWGNC in [21] [22]. Thus,
I E,C = 1 − I E,V (σ ch = 0, d v ← d c , I A,V ← 1 − I A,C ) = 1 − J (d c − 1) [J −1 (1 − I A,C )] 2 .(8)
For irregular LDPC codes, I E,V and I E,C are computed as weighted averages. The weighting is given by the coefficients of the "edge perspective" degree distribution polynomials
λ(z) = d v d=1 λ d z d−1 and ρ(z) = d c d=1 ρ d z d−1 ,
where λ d is the fraction of edges in the Tanner graph connected to degree-d variable nodes, ρ d is the fraction of edges connected to degreed check nodes, and λ(1) = ρ(1) = 1. Then, for irregular LDPC codes,
I E,V = dv d=1 λ d I E,V (d, I A,V )(9)
where I E,V (d) is given by (7) with d v replaced by d, and
I E,C = d c d=1 ρ d I E,C (d, I A,C )(10)
where I E,C (d) is given by (8) with d c replaced by d. It has been shown [11] that to optimize the decoding threshold on the binary erasure channel, the shapes of the VND and CND transfer curves must be well matched in the sense that the CND curve fits inside the VND curve (an example will follow). This situation has also been observed on the BI-AWGNC [15]. Further, to achieve a good match, the number of different VN degrees need only be about 3 or 4 and the number of different CN degrees need only be 1 or 2.

Example 1: We consider the design of a rate-1/2 irregular LDPC code with four possible VN degrees and two possible CN degrees. Given than λ(1) = ρ(1) = 1 and [16], [4], only two of the four coefficients for λ(z) need be specified and only one of the two for ρ(z) need be specified. A non-exhaustive search yielded λ(z) = 0.267z + 0.176z 2 + 0.127z 3 + 0.430z 9 and ρ(z) = 0.113z 4 + 0.887z 7 with a decoding threshold of (E b /N 0 ) thres = 0.414 dB. The EXIT chart for E b /N 0 = 0.55 dB is presented in Fig. 3. The figure also gives the "node perspective" degree distribution information.
R = 1 − 1 0 ρ(z)dz/ 1 0 λ(z)dz
The references contain additional information on EXIT charts, including the so-called area property, EXIT charts for the Rayleigh channel, for higher-order modulation, and for multi-input/multi-output channels [14][15] [11] [23].


## III. DESIGN OF PROTOGRAPH-BASED CODES


## A. Definition and Problem Statement

A protograph [24][25] [26][27] is a relatively small bipartite graph from which a larger graph can be obtained by a copyand-permute procedure: the protograph is copied Q times, and then the edges of the individual replicas are permuted among the replicas (under restrictions described below) to obtain a single, large graph. An example is presented in Fig.  4. The permuted edge connections are specified by the paritycheck matrix H. Note that the edge permutations cannot be arbitrary. In particular, the nodes of the protograph are labeled so that if variable node V is connected to check node C in the protograph, then variable node V in a replica can only connect to one of the Q replicated C check nodes. Doing so preserves the decoding threshold properties of the protograph. A protograph can possess parallel edges, i.e., two nodes can be connected by more than one edge. For LDPC codes, the copy-and-permute procedure must eliminate such parallel connections in order to obtain a derived graph appropriate for a parity-check matrix.

It is convenient to choose the parity-check matrix H as an M × N array of Q × Q (weight-one) circulant permutation matrices (some of which may be the Q × Q zero matrix). When H is an array of circulants, the LDPC code will be quasi-cyclic. Such a structure has a favorable impact on both the encoder and the decoder. The encoder for QC codes can be implemented with shift-register circuits with complexity linearly proportional to m for serial encoding and to n for parallel encoding [13]. By contrast, encoders for unstructured LDPC codes require much more work. The decoder for QC LDPC codes can be implemented in a modular fashion by exploiting the circulant-array structure of H [28] [29].

Below we present an extension of the EXIT approach to codes defined by protographs. This extension is a multidimensional numerical technique and as such does not have a two-dimensional EXIT chart representation of the iterative decoding procedure. Still, the technique yields decoding thresholds for LDPC code ensembles specified by protographs. This multi-dimensional technique is facilitated by the relatively small size of protographs and permits the analysis of protograph code ensembles characterized by the presence of critical node types, i.e., node types which can lead to failed EXIT-based convergence of code ensembles. Examples of critical node types are degree-1 variable nodes and punctured variable nodes.

A code ensemble specified by a protograph is a refinement (sub-ensemble) of a code ensemble specified simply by the protograph's (hence, LDPC code's) degree distributions. To demonstrate this, we introduce the adjacency matrix B = [b ji ] for a protograph, also called a base matrix [25], where b ji is the number of edges between CN j and VN i. As an example, for the protograph at the top of Fig. 4,
B = 2 1 1 1 1 1 .
Consider also an alternative protograph and base matrix specified by
B = 2 0 2 1 2 0 .
The degree distributions of both of these protographs are identical and are easily seen to be
λ(z) = 4 7 z + 3 7 z 2 ρ(z) = 3 7 z 2 + 4 7 z 3 .
However, the ensemble corresponding to B has a threshold of E b /N 0 = 0.78 dB and that corresponding to B has a threshold at 0.83 dB. (For reference, density evolution [16] applied to the above degree distributions gives 0.817 dB.) As another example, let noting that they have identical degree distributions. We also puncture the bits corresponding to the second column in each base matrix. Using the multidimensional EXIT algorithm described below, the thresholds for B and B in this case were computed to be 0.48 dB and +∞, respectively. Thus, standard EXIT analysis based on degree distributions is inadequate for protograph-based LDPC code design. In fact, the presence of degree-1 variable nodes as in our second example implies that there is a term in the summation in (9) of the form
λ 1 I E,V (1, I A,V ) = J (σ ch ) .
Since J (σ ch ) is always less than one for 0 < σ ch < ∞ and since d v d=1 λ d = 1, the summation in (9), that is, I E,V , will be strictly less than one. Again, standard EXIT analysis implies failed convergence for codes with the same degree distributions as B and B . This is in contrast with the fact that codes in the B ensemble do converge when the SNR exceeds the threshold of 0.48 dB.

In the following, a multidimensional EXIT technique [30][31] will be presented which overcomes this issue and allows the determination of the decoding threshold for codes based on protographs (possibly with punctured nodes).


## B. Multidimensional EXIT Analysis

The algorithm presented in [30][31] eliminates the average in (9) and considers the propagation of the messages on a decoding tree which is specified by the protograph of the ensemble. Let B = [b ji ] be the M × N base matrix for the protograph under analysis. Let I i→j E,V be the extrinsic mutual information between code bits associated with "type i" VNs and the LLRs L i→j sent from these VNs to "type j" CNs. Similarly, let I j→i E,C be the extrinsic mutual information between code bits associated with "type i" VNs and the LLRs L j→i sent from "type j" CNs to these VNs. Then, because I j→i
E,C
acts as a priori mutual information in the calculation of I i→j E,V , following (7) we have (given an edge exists between CN j and VN i, i.e., given b ji = 0)
I i→j E,V = J   M c=1 (b ci − δ cj ) J −1 (I c→i E,C ) 2 + σ 2 ch,i   ,(11)
where δ cj = 1 when c = j and δ cj = 0 when c = j. σ 2 ch,i is set to zero if code bit i is punctured. Similarly, because I i→j
E,V
acts as a priori mutual information in the calculation of I j→i E,C , following (8) we have (when b ji = 0)
I j→i E,C = 1 − J   N v=1 (b jv − δ ci ) J −1 (1 − I v→j E,V ) 2   .(12)
The multidimensional EXIT algorithm can now be presented as follows.

1) 
Initialization. Select E b /N 0 . Initialize a vector σ ch = (σ ch,0 , . . . , σ ch,N −1 ) such that σ ch,i = 8R E b N 0 i where (E b /N 0 ) iI i CM I = J   M c=1 J −1 (I c→i E,C ) 2 + σ 2 ch,i   .

## 5)

If I i CM I = 1 (up to desired precision) for all i, then stop; otherwise, go to step 2. This algorithm converges only when the selected E b /N 0 is above the threshold. Thus, the threshold is the lowest value of E b /N 0 for which all I i CM I converge to 1. As shown in [30] [31], the thresholds computed by this algorithm are typically within 0.05 dB of those computed by density evolution. Recalling that many classes of multi-edge type (MET) [26] LDPC codes rely on simple protographs, the above algorithm provides an accurate threshold estimation for MET ensembles, with a remarkable reduction in computational complexity relative to the density evolution analysis proposed in [26].


## IV. ACCUMULATOR-BASED CODE DESIGNS


## A. Repeat-Accumulate Codes

This section provides an overview of the design of LDPC codes that can be considered to be a concatenation of a set of repetition codes with one or more accumulators, through an interleaver. The first example of accumulator-based codes were the so-called repeat-accumulate (RA) codes [32]. Despite their simple structure, they were shown to provide good performance and, more importantly, they paved a path toward the design of efficiently encodable LDPC codes. RA codes and other accumulator-based codes are LDPC codes that can be decoded as serial turbo codes or as LDPC codes.

An RA code consists of a serial concatenation of a single rate-1/q repetition code through an interleaver with an accumulator having transfer function 1/(1 ⊕ D). RA codes can be either non-systematic or systematic. In the first case, the accumulator output, p, is the codeword and the code rate is 1/q. For systematic RA codes, the information word, u, is combined with p to yield the codeword c = [u p] and so that the code rate is 1/(1 + q). RA codes perform reasonably well on the AWGN channel, and they tend to approach the channel capacity as their rate R → 0 and their block length n → ∞. Their main limitations are the code rate, which cannot be higher than 1/2, and the performance of short and mediumlength RA codes. The following subsections will present a brief overview of the major enhancements to RA codes which permit operation closer to capacity for both high and low rates.


## B. Irregular Repeat-Accumulate codes

The systematic irregular repeat-accumulate (IRA) codes generalize the systematic RA codes in that the repetition rate may differ across the k information bits and that a variable number of bits in the repeated word are combined (modulo 2) prior to sending them through the accumulator. Irregular repeat-accumulate [33] codes provide several advantages over RA codes. They allowing both flexibility in the choice of the repetition rate for each information bit so that high rate codes may be designed and capacity is more easily approached. 57.8317in;original-height 7.0188in;cropleft "0";croptop "1";cropright The Tanner graph for IRA codes is presented in Fig. 5(a) and the encoder structure (to be discussed further later) is depicted in Fig. 5(b). The variable repetition rate is accounted for in the graph by letting d b,i vary with i. The accumulator is represented by the right-most part of the graph, where the dashed edge is added to include the possibility of a tail-biting trellis. Also, we see that d c,j interleaver output bits are added (modulo 2) to produce the j-th accumulator input. Fig. 5 also includes the representation for RA codes. As indicated in the table in the figure, for an RA code, each information bit node connects to exactly q check nodes (d b,i = q) and each check node connects to exactly one information bit node (d c,j = 1). We remark that {d b,i } and {d c,j } can be related to our earlier notation, {d v (i)} and {d c (j)}, as follows:
d v (i) = d b,i for i = 1, ..., k, d v (i) = 2 for i = k + 1, ..., n, and d c (j) = d c,j + 2 for j = 1, ..., m.
To determine the code rate for an IRA code, define q to be the average repetition rate of the information bits andā as the average of the degrees {d c,j },
q = 1 k k i=1 d b,i ,a = 1 m m j=1 d c,j .
Then the code rate for systematic IRA codes is
R = 1 1 + q/ā .
For non-systematic IRA codes, R =ā/q. The parity-check matrix for systematic RA and IRA codes has the form
H = [H u H p ],(13)
where H p is an m × m "dual-diagonal" square matrix,
H p =        1 (1) 1 1 . . . . . . 1 1 1 1        ,(14)
where the upper-right 1 is included for tailing-biting accumulators. For RA codes, H u is a regular matrix having column weight q and row weight 1. exists only when the "tail-biting 1" is absent). Two encoding alternatives exist: (1) When the accumulator is not tail-biting, one may use H to encode since one may solve for the parity bits sequentially from the equation cH T = 0 starting with the top row of H and moving on downward.

(2) As discussed in the next section, quasi-cyclic IRA code designs are possible, in which case the techniques of [13] may be used.

We remark that the choice of the degree distributions of the variable nodes for an IRA code are constrained by the presence of (at least) n − k − 1 degree-2 variable nodes. Although such a constraint ostensibly limits the code designer, for rates R ≥ 1/2, EXIT analysis leads to optimized degree distributions having approximately n − k − 1 degree-2 variable nodes. Moreover, when the number of degree-2 variable nodes is exactly n−k−1, the edge connections involving the degree-2 variable nodes induced by the IRA structure are optimal in the sense of avoiding low weight codewords [34] [35].

IRA codes and a generalization will be discussed in the next two sections. Additional information may be found in the following references: [ 


## C. Structured IRA and IRAA Codes

Given the code rate, length, and degree distributions, an IRA code is defined entirely by the matrix H u (equivalently, by A and Π). While a random-like H u would generally give good performance, it is problematic for both encoder and decoder implementations. For, in this case, a substantial amount of memory would be required to store the connection information implicit in H u . In addition, although standard message-passing decoding algorithms for LDPC codes are inherently parallel, the physical interconnections required to realize a code's bipartite graph becomes an implementation bottleneck and prohibits a fully parallel decoder [29]. Using a structured H u matrix mitigates these problems.

Tanner [24] was the first to consider structured RA codes, more specifically, quasi-cyclic RA codes, which require tailbiting in the accumulator. Simulation results in [24] demonstrate that the QC-RA codes compete well with random-like RA codes and surpass their performance at high SNR values. Similar ideas were applied to IRA codes in [29][44] [36]. In [36], IRA codes with quasi-cyclic structure are called structured IRA (S-IRA) codes.

Toward the goal of attaining structure in H, one cannot simply choose H u to be an array of circulant permutation matrices. For, it is easy to show that doing so will produce a poor LDPC code in the sense of minimum distance (consider weight-2 encoder inputs with adjacent ones). Instead, the following strategy is proposed in [36]. Let P be an L×J array of Q × Q circulant permutation matrices (for some convenient Q). (Conditions for designing P to avoid 4-cycles, etc., are described in [36].) Then set A T = P so that H u = Π T P and
H a = Π T P H p ,(15)
where H p represents the tailbiting accumulator. Note that m = L × Q and k = J × Q. We now choose Π to be a standard deterministic "rowcolumn" interleaver so that row lQ + q in P becomes row qL + l in Π T P, for all 0 ≤ l < L and 0 ≤ q < Q. Next, we permute the rows of H a by Π −T to obtain where we have used the fact that Π −T = Π. Finally, we permute only the columns corresponding to the parity part of H b , which gives
H b = Π −T H = [P ΠH p ],(16)H S-IRA = [P ΠH p Π T ].(17)
It is easily shown that the parity part of H S-IRA , that is,
ΠH p Π T , is exactly in QC form,        I 0 I 1 I 0 I 0 . . . . . . I 0 I 0 I 0 I 0        ,(18)
where I 0 is the Q × Q identity matrix and I 1 is obtained from I 0 by cyclically shifting all of its rows leftward. Therefore, H S-IRA corresponds to a quasi-cyclic IRA code since P is also an array of Q×Q circulant permutation matrices. Observe that, except for a re-ordering of the parity bits, H S-IRA describes the same code as H a and H b . As described in [36], in addition to simplifying encoder and decoder implementations, the QC structure simplifies the code design process. Simulation results for the example codes, which are produced by the design algorithms proposed in [36][37] [38] [39], show that the S-IRA codes perform as well as IRA codes in the waterfall region and possess very low error floors. As an example, Fig. 6 depicts the performance of a rate-1/2 (2044, 1024) S-IRA code simulated in software and hardware. 1 It is seen that the floors, both bit error rate (BER) and frame error rate (FER), are quite low (it can be lower or higher depending on the decoder implementation). Lastly, S-IRA codes are suitable for rate-compatible code family design [36].

We now consider irregular repeat-accumulate-accumulate (IRAA) codes which are obtained by concatenating the parity arm of the IRA encoder of Fig. 5(b) with another accumulator, through a permuter, as shown in Fig. 7. (ARAA codes were   Fig. 9. The shaded node in the SIRAA protograph represents punctured bits. SIRA:
(E b /N 0 ) thres = 0.97 dB. SIRAA: (E b /N 0 ) thres = 1.1 dB.
considered in [49]. 
H IRAA = H u H p 0 0 Π T 1 H p ,(19)
where Π 1 is the interleaver between the two accumulators. When the parity bits b are not transmitted, they are considered to be punctured, that is, the log-likelihood ratios for these bits are initialized by zeros before decoding. When an IRAA code is structured, we use the notation S-IRAA. Example 2: We compare the performance of rate-1/2 (2048, 1024) S-IRA and S-IRAA codes in this example. For the S-IRA code, d b,i = 5 for all i and for the S-IRAA code, d b,i = 3 for all i, and the intermediate parity vector b is not transmitted to maintain the code rate at 1/2. The protographs for these codes are given in Fig. 8. Because decoder complexity is proportional to the number of edges in a code's parity-check matrix, the complexity of the S-IRAA decoder is slightly greater than the complexity of the S-IRA decoder, even though the column weight in H u is 3 for the former versus 5 for the latter. We observe in Fig. 9 that, for both codes, there are no error floors in the BER curves down to BER = 5 × 10 −8 and in the FER curves down to FER = 10 −6 . While the S-IRAA code is 0.2 dB inferior to the S-IRA code in the waterfall region, we conjecture that it has a lower floor (which is difficult to measure), which would be due to the second accumulator whose function is to increase minimum distance.

Example 3: This second example is a comparison of rate-1/3 (3072,1024) S-IRA and S-IRAA codes, with d b,i = 4 for the S-IRA code and d b,i = 3 for the S-IRAA code. The protographs for these codes are given in Fig. 10. In this case, b is part of the transmitted S-IRAA codeword and the decoder complexities are the same. We see in Fig. 11 that, in the low SNR region, the performance of the S-IRA code is 0.4 dB better than the S-IRAA code. However, for high SNRs, the S-   IRAA code will outperform the S-IRA code due to its lower error floor.
b /N 0 [dB] BER/FER BER:S−IRA(d b,i =5) FER:S−IRA(d b,i =5) BER:S−IRAA(d b,i =3) FER:S−IRAA(d b,i =3)

## D. Generalized IRA codes

Generalized IRA (G-IRA) codes [40] [41] increase the flexibility in choosing degree distributions relative to IRA codes, allowing, for example, the design of near-regular efficiently encodable codes. The encoding algorithms for G-IRA codes are similar to those of IRA codes. For G-IRA codes, the accumulator 1/(1⊕D) in Fig. 5(b) is replaced by a generalized accumulator with transfer function 1/g(D) where g(D) = t j=0 g j D j and g j ∈ {0, 1}, except g 0 = 1. The systematic encoder therefore has the same generator matrix format,   To design a G-IRA code, one must choose g(D) so that the bipartite graph for H p contains no length-4 cycles [40]. Once g(D) has been chosen, H can be completed by constructing the sub-matrix H u , according to some prescribed degree distribution, again avoiding short cycles, this time in all of H.
G = I H T u H −T p , but now H p =                  1 g 1 1 g 2 g 1 . . . . . .g t . . . g 2 g 1 1                  . Further, the parity-check matrix format is unchanged, H = [H u H p ].E b /N 0 [dB] BER/FER BER:S−IRA(d b,i =4) FER:S−IRA(d b,i =4) BER:S−IRAA(d b,i =3) FER:S−IRAA(d b,i =3)
G-IRA codes are highly reconfigurable in the sense that an encoder and decoder can be designed for a set of different polynomials g(D). This could be useful when faced with different channels conditions.


## E. Accumulate-Repeat-Accumulate Codes

For accumulate-repeat-accumulate (ARA) codes, introduced in [45], an accumulator is added to precode a subset of the information bits of an IRA code. The primary role of this second accumulator is to improved the decoding threshold of a code, that is, to shift the BER waterfall region leftward. ARA codes are a subclass of LDPC codes and Fig. 12 presents a generic ARA Tanner graph in which punctured variable nodes are highlighted. The sparseness of the ARA graph is achieved at the price of these punctured variable nodes which act as auxiliary nodes that enlarge the H used by the decoder. The iterative graph-based ARA decoder thus has to deal with a redundant representation of the code, implying a larger H matrix than the nominal (n − k) × n. This issue, together with the presence of a large number of degree-1 and degree-2 variable nodes, results in slow decoding convergence.

The ARA codes presented in [45] relies on very simple protographs. Several modified ARA protographs have been introduced in [46] [47], leading to ARA and ARA-like code families with excellent performance in both the waterfall and floor regions of the codes' performance curves. The protograph of a rate-1/2 ARA code ensemble with repetition rate 4, denoted AR4A, is depicted in Fig. 13(a). The dark circle corresponds to a state-variable node, and it is associated with the precoded fraction of the information bits. As emphasized in the figure, such a protograph is the serial concatenation of an accumulator protograph and an IRA protograph.

Half
Π f f f f f f . . . . . . . . . . . . . . . . . . . . .
. . .   (node 2) of the information bits are sent directly to the IRA encoder, while the other half (node 1) is first precoded by the outer accumulator. This encoding procedure corresponds to a systematic code. A different code structure is represented by the protograph in Fig. 13(b), which has a parallel-concatenated form. In this case, half (node 2) of the information bits are encoded by the IRA encoder and the other half (node 3) are encoded by both the IRA encoder and a (3, 2) single-parity-check encoder. The node-3 information bits (corresponding to the dark circle in the protograph) are punctured and so codes corresponding to this protograph are non-systematic. While the codes (actually, code ensembles) specified by the protographs in Fig. 13(a) are the same in the sense that the same set of codewords are implied, the u → c mappings are different. The advantage of the non-systematic protograph is that, although the node-3 information bits in Fig. 13(b) are punctured, the node degree is 6, in contrast with the node-1 information bits in Fig. 13(a), in which the node degree is only 1. Given that ARA code decoders converge so slowly, the faster-converging degree-6 node is to be preferred over the slowly converging degree-1 node.

To demonstrate this, we designed a (2048,1024) QC AR4A code whose H matrix is depicted in Fig. 14. The first group of 512 columns (of weight 6) correspond to variable node type 1 (Fig. 13) whose bits are punctured, and the subsequent four groups of 512 columns correspond, respectively, to node types 2, 3, 4, and 5. The first group of 512 rows correspond to check node type A, and the two subsequent groups of rows correspond to node types B and C, respectively. The performance of the code, with a maximum of I max = 50 iterations is shown in Fig. 15. We note that the (2048,1024) AR4A code reported in [47] achieves BER = 10 −7 at E b /N 0 = 2 dB with 200 iterations, whereas in the simulation here, BER = 10 −7 is achieved at E b /N 0 = 2.2 dB with 50 iterations. In Fig. 16, we present the BER performance at E b /N 0 = 2.25 dB for the five node types that appear in Fig. 13 for I max ranging from 5 to 20. With 20 iterations, we collected 400 error events, while with fewer iterations, the numbers of collected error events were larger. From the figure, we see that the high-degree variable nodes (node types 2 and 3) converge the fastest. We note also that, while type 3 nodes have degree 6 and type 2 nodes have degree 4, type 3 nodes initially converge slower because the bits corresponding to those nodes are punctured so that the decoder receives no channel LLRs for those bits. However, by 20 iterations, the type 3 bits become more reliable than the type 2 bits.


## F. Accumulator-Based Codes in Standards

IRA codes and IRA-influenced codes are being considered for several communication standards. The ETSI DVB S2 [48] standard for digital video broadcast specifies two IRA code families with block lengths 64800 and 16200. The code rates supported by this standard range from 1/4 to 9/10, and a wide range of spectral efficiencies is achieved by coupling these LDPC codes with QPSK, 8-PSK, 16-APSK, and 32-APSK    The IEEE standards bodies are also considering IRAinfluenced QC LDPC codes for 802.11n (wireless local-area networks) and 802.16e (wireless metropolitan-area networks). Rather than employing a tailing-biting accumulator (which avoids weight-one columns), these standards have replaced the last block-column in (18) with a weight-three block-column and moved it to the first column, as displayed below. Encoding is facilitated by this matrix since the sum of all block-rows gives the block-row I 0 0 · · · 0 , so that encoding is initialized by summing all of the block-rows of H and solving for first Q parity bits using the resulting block-row. 
            I 0 I 0 I 0 I 0 I 0 . . . I 0 . . . . . . . . . I 0 I 0 I 0 I 0 I 0             
ARA codes are being considered by the Consultative Committee for Space Data Systems (CCSDS) for high data-rate bandwidth-efficient space links. Very low floors are required for this applications because the scientific data (e.g., images) being transmitted from space to the ground are typically in a compressed format.


## V. LDPC CODES BASED ON FINITE GEOMETRIES

In [50], it is shown that structured LDPC codes can be constructed based on the lines and points of geometries over finite fields, namely Euclidean and projective geometries. These codes are known as finite-geometry (FG) LDPC codes. Among the FG-LDPC codes, an important subclass is the subclass of cyclic FG-LDPC codes. A cyclic LDPC code is completely characterized by its generator polynomial and its encoding can be implemented with a shift-register with feedback connections based on its generator polynomial [7]. The systematic-form generator matrix of a cyclic LDPC code can be constructed easily based on its generator polynomial [7]. Another important subclass of FG-LDPC codes is the subclass of quasi-cyclic FG-LDPC codes. As pointed out earlier, QC-LDPC codes can also be encoded easily with simple shift-registers. In this section, we give a brief survey of constructions of cyclic and quasi-cyclic FG-LDPC codes.


## A. Cyclic Euclidean Geometry LDPC Codes

The m-dimensional Euclidean geometry over the finite field GF(q) [7] Then, the elements 0, 1, α, α 2 , . . . , α q m −2 of GF(q m ) represent the q m points of EG(m, q), and 0 represents the origin of the geometry. A line is a set of points of the form {a + βa : β ∈ GF(q)}, where a and a are linearly independent over GF(q).

Let n EG = q m − 1 be the number of non-origin points in the geometry. Let L be a line not passing through the origin. Define the n EG -tuple over GF (2),
v L = (v 0 , v 1 , . . . , v n EG −2 ),
whose components correspond to the q m −1 non-origin points,
α 0 , α, · · · , α q m −2 , of EG(m, q), where v i = 1 if the point α i lies on L, otherwise v i = 0.
The vector v L is called the incidence vector of L. Clearly, αL is also a line in the geometry whose incidence vector v αL is the right cyclic-shift of v L . The lines L, αL, · · · , α n EG −1 L are all different [7] and they do not pass through the origin. Since α q m −1 = 1, α n EG L = L. These n EG lines form a cyclic class. The (q m−1 − 1)(q m − 1)/(q − 1) lines in EG(m, q) not passing through the origin can be partitioned into
K = (q m−1 − 1)/(q − 1) cyclic classes, denoted Q 1 , Q 2 , · · · , Q K where Q i = {L i , αL i , · · · , α n EG −1 L i } with 1 ≤ i ≤ K.
For each cyclic class Q i , we form an n EG × n EG matrix H EG,i over GF(2) with the incidence vectors L i , αL i , · · · , α n EG −1 L i as rows. H EG,i is a circulant matrix with column and row weights equal to q.
For 1 ≤ k ≤ K, let H EG(m,q),k =      H EG,1 H EG,2 . . . H EG,k      .(20)
Then H EG(m,q),k consists of a column of k circulants of the same size n EG × n EG , and it has column and row weights, kq and q, respectively. Since no two lines in EG(m, q) have more than one point in common, it follows that no two rows or two columns in H EG(m,q),k have more than a single 1-element in common. We say that H EG(m,q),k satisfies the RC-constraint. The null space of H EG(m,q),k gives a cyclic EG-LDPC code of length n EG = q m − 1 and minimum distance at least kq + 1 [50][7], whose Tanner graph has a girth of at least 6. Of particular interest is the two-dimensional Euclidean geometry, EG(2, q), which is also called an affine plane over GF(q) [52]. This geometry has q 2 points and q(q + 1) lines, and q 2 − 1 of them do not pass through the origin. Each line has q points and each point lies on q + 1 lines. Each nonorigin point lies on q lines that do not pass through the origin. If L is a line in EG(2, q) not passing through the origin, then L, αL, . . . , α q 2 −2 L, where α is a primitive element in GF(q 2 ), are all the lines in the geometry not passing through the origin. Hence, all the lines in EG(2, q) not passing through the origin form a single cyclic class Q (i.e., K = 1). Let H EG(2,q) denote the (q 2 −1)×(q 2 −1) circulant formed by the incidence vectors of lines in Q. It is a (q 2 −1)×(q 2 −1) matrix over GF(2) with both column and row weights equal to q. The null space of H EG(2,q) gives a cyclic EG-LDPC code of length q 2 − 1 and minimum distance at least q + 1. For q = 2 s , the parameters of the code with parity-check matrix H EG(2,q) are as follows [7]:
Length n = 2 2s − 1, Number of parity bits n − k = 3 s − 1, Dimension k = 2 2s − 3 s , Minimum distance d min ≥ 2 s + 1, Size of the LDPC matrix (2 2s − 1) × (2 2s − 1), Row weight 2 s , Column weight 2 s .
Generators polynomials for these codes can be readily obtained from [7]. Example 4: The cyclic LDPC code constructed based on the two-dimensional Euclidean geometry EG(2, 2 6 ) over GF (2 6 ) is a (4095, 3367) LDPC code with rate 0.822 and minimum distance 65. The performance of this code with iterative decoding using the SPA is shown in Fig. 17. At a BER of 10 −6 , it performs 1.65 dB from the Shannon limit. Since it has a very large minimum distance, it has a very low error-floor.


## B. Cyclic Projective Geometry LDPC Codes

The m-dimensional projective geometry over GF(q), denoted by PG(m, q), consists of n PG = (q m+1 − 1)/(q − 1) points. Each point is represented by a non-zero (m + 1)-tuple a over GF(q) such that all q − 1 non-zero multiples βa, where β is a non-zero element in GF(q), represent the same point. A line in PG(m, q) consists of all points of the form β 1 a 1 +β 2 a 2 , where a 1 and a 2 are two (m + 1)-tuples that are linearly independent over GF(q) and β 1 and β 2 are elements in GF(q), with β 1 and β 2 not simultaneously equal to zero. There are (q m+1 − 1)(q m − 1)/(q 2 − 1)(q − 1) lines in PG(m, q) and each line consists of q +1 points. Two points are connected by one and only one line and each point lies on (q m − 1)/(q − 1) lines.

The extension field GF(q m+1 ) of GF(q) is a realization of PG(m, q) [7]. Let α be a primitive element of GF(q m+1 ). A point in PG(m, q) is represented by a non-zero element α i . Every nonzero element in the base field GF(q) can be written as α l for some l which is divisible by (q m+1 − 1)/(q − 1). Hence, the elements α i and α j represent the same point in PG(m, q) if and only if i ≡ j (mod (q m+1 − 1)/(q − 1)). Therefore, we can take the elements 1, α, . . . , α n PG −1 to represent all the points in PG(m, q).

Let L be a line in PG(m, q). Define the n PG -tuple over GF(2) v L = (v 0 , v 1 , . . . , v n PG −1 ) whose components correspond to the n PG = (q m+1 − 1)/(q − 1) points of PG(m, q), where v i = 1 if the point represented by α i lies on L, otherwise v i = 0. The vector v L is called the incidence vector of L. Clearly, αL is also a line in the geometry whose incidence vector v αL is the cyclic-shift of v L .

For even m, the lines in PG(m, q) can be partitioned into K 1 = (q m − 1)/(q 2 − 1) cyclic classes Q 1 , Q 2 , · · · , Q K 1 , each class consisting of n PG lines. For each cyclic class Q i , we can form an n PG ×n PG circulant H PG,i with both column and row weights equal to q + 1. For 1 ≤ k ≤ K 1 , form the following matrix:
H (1) PG(m,q),k =      H PG,1 H PG,2 . . . H PG,k      ,(21)
which has column and row weights k(q + 1) and q + 1, respectively. The null space of H

PG(m,q),k gives a cyclic PG-LDPC code of length n PG = (q m+1 −1)/(q−1) and minimum distance at least k(q + 1) + 1 whose Tanner graph has a girth of at least 6. For odd m, the lines in PG(m, q) can be partitioned into K 2 + 1 cyclic classes, Q 0 , Q 1 , Q 2 , · · · , Q K 2 , where K 2 = q(q m−1 −1)/(q 2 −1). Except for Q 0 , each cyclic class consists of n PG lines. The cyclic class Q 0 consists of only λ = (q m+1 − 1)/(q 2 − 1) lines. For each cyclic class Q i with i = 0, we can form a n PG ×n PG circulant H PG,i with the incidence vectors of the lines in Q i as rows. For 1 ≤ k ≤ K 2 , we can form a matrix H (2) PG(m,q),k of the form given by (21). The null space of H (2) PG(m,q),k gives a cyclic PG-LDPC code of length n PG and minimum distance at least k(q + 1) + 1 whose Tanner graph has a girth of at least 6.

As in the case of Euclidean geometries, the two-dimensional projective geometry, PG(2, q), which is also called a projective plane over GF(q) [52], is of particular interest. This geometry has q 2 + q + 1 points and q 2 + q + 1 lines. Each line has q + 1 points and each point lies on q + 1 lines. If L is a line in PG(2, q), then L, αL, . . . , α q 2 +q L, where α is a primitive element in GF(q 2 ), are all the lines in the geometry. Hence, all the lines in PG(2, q) form a single cyclic class Q (i.e., K 1 = 1). Let H PG(2,q) denote the n PG ×n PG circulant formed by the incidence vectors of the lines in Q. It is a (q 2 + q + 1) × (q 2 + q + 1) matrix over GF(2) with both column and row weights equal to q + 1. The null space of H PG(2,q) gives a cyclic PG-LDPC code of length q 2 + q + 1 and minimum distance at least q + 2. For q = 2 s , the parameters of the cyclic PG-LDPC code given by the null space of H PG(2,q) are as follows [7]:

Length n = 2 2s + 2 s + 1, Number of parity bits n − k = 3 s + 1, Dimension k = 2 2s + 2 s − 3 s , Minimum distance d min ≥ 2 s + 2, Size of the LDPC matrix (2 2s + 2 s + 1) × (2 2s + 2 s + 1), Row weight 2 s + 1, Column weight 2 s + 1.

Generators polynomials for these codes can also be readily obtained from [7].


## C. Quasi-Cyclic Finite Geometry LDPC Codes

Let R EG(m,q),k be the transpose of the parity-check matrix H EG(m,q),k of a cyclic EG-LDPC code given by (20), i.e.,
R EG(m,q),k H T EG(m,q),k = [H T 1 H T 2 · · · H T k ],(22)
which consists of a row of k circulants of size n EG × n EG . It is a (q m − 1) × k(q m − 1) matrix with column and row weights q and kq, respectively. The null space of R EG(m,q),k gives a quasi-cyclic EG-LDPC code of length k(q m − 1) and minimum distance at least q + 1 whose Tanner graph has a girth of at least 6. Similarly, let R PG(m,q),k gives a quasi-cyclic PG-LDPC code of length k(q m+1 − 1)/(q − 1) and minimum distance at least q + 2.

Example 5: Consider the 3-dimensional projective geometries PG(3, 2 3 ) over GF (2 3 ). This geometry consists of 585 points and 4745 lines, each line consists of 9 points. The lines in this geometry can be partitioned into 9 cyclic classes, Q 0 , Q 1 , · · · , Q 8 , where Q 0 consists of 65 lines and each of the other 8 cyclic classes consists of 585 lines. For each Q i with 1 ≤ i ≤ 8, we can form a 585 × 585 circulant H PG,i over GF (2) with the incidence vectors in Q i as the rows. Set k = 6. Form the following 585 × 3510 matrix: R 6 ], which has column and row weights 9 and 54, respectively. The null space of this matrix gives a (3510, 3109) quasi-cyclic PG-LDPC code with rate 0.8858 and minimum distance at least 10. The performance of this code decoded with iterative decoding using the SPA is shown in Fig. 18. At a BER of 10 −6 , it performs 1.3 dB from the Shannon limit.
(2) PG(3,2 3 ),6 = [H T PG,1 H T PG,2 · · · H T PG,
Other LDPC codes constructed based on finite geometries can be found in [53][54] [55][56] [57]. Finite geometry LDPC codes can also be effectively decoded with one-step majoritylogic decoding [7], hard-decision bit-flipping (BF) decoding [1][50] [7] and weighted BF decoding [50] [58][59] [60]. These decoding methods together with the soft-input and soft-output (SISO) iterative decoding based on belief propagation offer various trade-offs between performance and decoding complexity. The one-step majority-logic decoding requires the least decoding complexity while the (SISO) iterative decoding based on belief propagation requires the most decoding complexity and the other two decoding methods are in between. Fig. 19 shows the performances of the (4095,3367) cyclic EG-LDPC code given in Example 4 with various decoding methods. 


## VI. REGULAR RS-BASED LDPC CODES

This section first gives a brief survey of a class of structured LDPC codes that are constructed from the codewords of Reed-Solomon (RS) codes with two information symbols. Then two new classes of Reed-Solomon-based quasi-cyclic LDPC codes are presented. Experimental results show that constructed codes perform very well over the AWGN channel with iterative decoding.

In [61], a class of structured regular LDPC codes was presented which were constructed from the codewords of RS codes with two information symbols. These codes are referred to as RS-based LDPC codes and their parity-check matrices are arrays of permutation matrices. RS-based LDPC codes perform well with iterative decoding over the AWGN channel. Most importantly, they have low error-floors and their decoding converges very fast. These features are important in high-speed communication systems where very low error rates are required, such as the 10G Base-T Ethernet. In this section, we first give a more general form of the RS-based LDPC codes presented in [61] and then we present two classes of RS-based QC LDPC codes.

Let α be a primitive element of the finite field GF(q). Then the following powers of α, α −∞ 0, α 0 = 1, α, . . . , α q−2 , form the q elements of GF(q) and α q−1 = 1. For i = −∞, 0, 1, · · · , q − 2, represent each element α i of GF(q) by a q-tuple over GF (2),
z(α i ) = (z −∞ , z 0 , z 1 , z 2 , . . . , z q−2 ),(23)
with components corresponding to the q elements, α −∞ , α 0 , · · · , α q−2 , of GF(q), where the i-th component z i = 1 and all the other components equal to zero. This binary q-tuple z(α i ) is an unit-vector with one and only one 1-component and is called the location vector of α i . It is clear that the location vectors of two different elements in GF(q) have their 1-components at two different locations. Suppose we form a q × q matrix A over GF (2) with the location vectors of the q elements of GF(q) as rows arranged in any order. Then A is a q × q permutation matrix.

Consider an extended (q, 2, q − 1) RS code C b over GF(q) [7] of length q with two information symbols and minimum distance q−1. The nonzero codewords of C b have two different weights, q − 1 and q. Because the minimum distance of C b is q − 1, two codewords in C b differ in at least q − 1 places, i.e., they have at most one place where they have the same code symbols. Let v be a nonzero codeword in C b with weight q. Then, the set C (0) b = {cv : c ∈ GF (q)} of q codewords in C b of weight q forms a one-dimensional subcode of C b with minimum distance q and is a (q, 1, q) extended RS code over GF(q). Any two codewords in C (0) b differ at every location.
Partition C b into q cosets, C (0) b , C (1) b , · · · , C (q−1) b
, based on the subcode C with i = j differ in at least q − 1 locations. For 0 ≤ i < q, form a q × q matrix G i over GF(q) with the codewords in C (i) b as rows. Then all the q entries in a column of G i are different and they form all the q elements of GF(q). It follows from the structural properties of the cosets of C (0) b that any two rows from any matrix G i differ at every position and any two rows from two different matrices G i and G j with i = j can have at most one location where they have identical symbols.

For 0 ≤ i < q, replacing each entry in G i by its location vector, we obtain a q×q 2 matrix B i over GF(2) which consists of a row of q permutation matrices of size q × q,
B i = [A i,0 A i,1 · · · A i,q ],(24)
where A i,j has the location vectors of the q entries of the j-th column of G i as rows. Next, we form the following q × q array of q × q permutation matrices with B 0 , B 1 , · · · , B q−1 as submatrices arranged in a column:
H rs,1 =      B 0 B 1 . . . B q−1      (25) =      A 0,0 A 0,1 · · · A 0,q−1 A 1,0 A 1,1 · · · A 1,q−1 . . . . . . . . . . . . A q−1,0 A q−1,1 · · · A q−1,q−1      .
H rs,1 is a q 2 × q 2 matrix over GF (2) with both column and row weights q. For q > 7, each permutation matrix A i,j is a sparse matrix and hence H rs,1 is also a sparse matrix. It follows from the structural properties of the matrices G i 's that no two rows (or two columns) of H rs,1 can have more than one 1-component in common. This implies that there are no four 1-components at the four corners of a rectangle in H rs,1 , that is, H rs,1 satisfies the RC-constraint and, hence, has a girth of at least 6 [50] [7]. For any pair of integers,  [7], whose Tanner graph has a girth of at least 6. Since H rs,1 consists of an array of permutation matrices, no odd number of columns of H rs,1 can be added to zero. This implies that the RS-based regular LDPC code C rs,1 has only even-weight codewords. Consequently, its minimum distance is even, at least d v + 2 for even d v and d v + 1 for odd d v . The above construction gives a class of regular LDPC codes whose Tanner graphs have girth at least 6. For each (q, 2, q − 1) extended RS code C b over GF(q), we can construct a family of regular RS-based LDPC codes with various lengths, rates and minimum distances. C b is referred to as the base code.  H rs,1 (6, 32) is a 384 × 2048 matrix over GF(2) with column and row weights 6 and 32, respectively. The null space of this matrix gives a (2048, 1723) regular RS-based LDPC code with rate 0.841 and minimum distance at least 8. Assume transmission over the AWGN channel with BPSK signaling. The performance of this code with iterative decoding using the SPA (50 iterations) is shown in Fig. 20. At a BER of 10 −6 , the code performs 1.55 dB from the Shannon limit. The standard code for the IEEE 802.2 10G Base-T Ethernet is a (2048, 1723) regular RS-based LDPC code given by the null space of a 6 × 32 subarray of the array H rs,1 constructed above. 
(d v , d c ), with 1 ≤ d v , d c ≤ q, let H rs,1 (d v , d c ) be a d v × d c subarray of H rs,1 . Then H rs,1 (d v , d c ) is a d v q × d c q matrix

## A. Class-I RS-Based QC-LDPC Codes

RS codes were originally defined in polynomial form in frequency domain [63]. Using the polynomial form, arrays of circulant permutation matrices that satisfy the RC-constraint can be constructed from all the codewords of an RS code over a prime field GF(p) with two information symbols. Based on these arrays of circulant permutation matrices, a class of QC-LDPC codes can be constructed.

Let p be a prime. Consider the prime field GF(p) = {0, 1, · · · , p − 1} under modulo-p addition and multiplication. Let P = {a(X) = a 1 X + a 0 : a 1 , a 0 ∈ GF (p)} be the set of p 2 polynomials of degree one or less with coefficients from GF(p). For each polynomial a(X) in P, define the following p-tuple over GF(p): v = (a(0), a(1), · · · , a(p − 1)), where a(j) = a 1 · j + a 0 with j ∈ GF (p). Then the set of p 2 ptuples, (1), · · · , a(p − 1)) : a(X) ∈ P}, (26) gives a (p, 2, p − 1) RS code over GF(p) with two information symbols. The RS code C b given by (26) is not cyclic.
C b = {v = (a(0), a
Consider the subset P 0 = {a(X) = a 0 : a 0 ∈ GF (p)} of zero-degree polynomials in P. Then the set of p-tuples,
C (0) b = {(a(0), a(1), · · · , a(p − 1)) : a(X) ∈ P 0 } = {(a 0 , a 0 , · · · , a 0 ) : a 0 ∈ GF (p)} ,(27)
constructed from the zero-degree polynomials in P 0 forms a one-dimensional subcode of C b and is a (p, 1, p − 1) RS code over GF (p) with minimum distance p. (0), · · · , a(p−1)) : a(X) = iX+a 0 , a 0 ∈ GF (p)}.
Partition C b with respect to C (0) b into p cosets, C (0) b , C (1) b , · · · , C (p−1) b , where C (i) b = {(aFor 0 ≤ i < p, C (i) b(28)
contains p codewords in C b of the following form:
(i · 0 + a 0 , i · 1 + a 0 , · · · , i · (p − 1) + a 0 ).(29)
The
codeword (i · 0, i · 1, ..., i · (p − 1)) in C (i) b
is the coset leader.

For 0 ≤ i < p, form a p × p matrix G i over GF(p) with the codewords in the i-th coset C (i) b as rows. For 0 ≤ j < p, the j-th column of G i consists of the following entries: i · j + 0, i · j + 1, · · · , i · j + (p − 1), which form all the p elements of GF(p). From (27) to (29), we readily see that any two rows in G i differ in all p places. Replacing each entry in G i by its location vector, we obtain a row of p permutation matrices of size p × p,
B i = [ A i,0 A i,1 · · · A i,p−1 ],
where A i,j has the location vectors of i · j + 0, i · j + 1, · · · , i · j + (p − 1) as the rows,
A i,j =      z(i · j + 0) z(i · j + 1) . . . z(i · j + (p − 1))      .(30)
Under modulo-p addition and multiplication, the location vector z(i · j + (k + 1)) of the field element i · j + (k + 1) is the right cyclic-shift (one place to the right) of the location vector z(i · j + k) of the field element of i · j + k and z(i · j + 0) is the right cyclic-shift of z(i · j + (p − 1)). Therefore A i,j is not just a permutation matrix but also a circulant, called a circulant permutation matrix. For 0 ≤ i < p, B i is hence a row of p circulant permutation matrices of size p × p. Form the following p×p array of p×p circulant permutation matrices:
H rs,2 =      B 0 B 1 . . . B p−1      (31) =      A 0,0 A 0,1 · · · A 0,p−1 A 1,0 A 1,1 · · · A 1,p−1 . . . . . . . . . . . . A p−1,0 A p−1,1 · · · A p−1,p−1      .
H rs,2 is a p 2 × p 2 matrix over GF(2) with both column and row weights p. Since the rows of H rs,2 correspond to the codewords in the (p, 2, p − 1) RS code C b over GF(p) given by (26) and two codewords in C b can have at most one place with the same code symbol, no two rows (or two columns) in H rs,2 can have more than one 1-component in common.

Hence H rs,2 satisfies the RC-constraint and its associated Tanner graph has a girth of at least 6. For any pair of integers, (2) with column and row weights d v and d c , respectively, and it also satisfies the RC-constraint. The null space of H rs,2 (d v , d c ) gives a regular RS-based QC-LDPC code of length d c p with rate at least (d c − d v )/d c and minimum distance at least d v + 2 for even d v , and d v + 1 for odd d v , whose Tanner graph has a girth of at least 6. The above construction gives a class of QC-LDPC codes with various lengths, rates and minimum distances.
(d v , d c ), with 1 ≤ d v , d c ≤ p, let H rs,2 (d v , d c ) be a d v × d c subarray of H rs,2 . H rs,2 (d v , d c ) is a d v p × d c p matrix over GF
Example 7: Consider the (73, 2, 72) RS code C b over the prime field GF(73) that is constructed based on the set of gives a (5256, 4895) regular RS-based QC-LDPC code with rate 0.9313. The minimum distance of this code is estimated to be 12 which is twice as large as its lower bound d v + 1 = 6. The performance of this code with iterative decoding using the SPA with 50 iterations is shown in Fig. 21. At a BER of 10 −6 , it perform 1.15 dB from the Shannon limit. The rate of decoding convergence of this code is shown in Fig. 22. We see decoding of this code converges very fast. At a BER of 10 −6 , the gap between 5 and 50 iterations is about 0.2 dB.


## B. Class-II RS-Based QC-LDPC Codes

So far in this section, we have presented two classes of RS-based LDPC codes. A code in either class is constructed based on partitioning all the codewords of an extended RS code with two information symbols into cosets with respect to a one-dimensional RS subcode. In this subsection, we present another class of RS-based LDPC codes. The construction of this class of LDPC codes is based on only the minimum weight (m-w) codewords of extended RS codes with two information symbols. In the construction, the m-w codewords of an extended RS code with two information symbols are first partitioned into q uniform classes (defined below), each with q − 1 m-w codewords. Then based on these uniform classes, a q × q array of (q − 1) × (q − 1) circulant permutation matrices is formed. The null space of any subarray of this array of circulant permutation matrices gives a QC-LDPC code.

Earlier we defined the location vector of an element in the Galois field GF(q) as a q-tuple with exactly one 1component. In our new construction of RS-based LDPC codes, we introduce a new type of location vector for the elements of GF(q). Let α be a primitive element in GF(q). For each nonzero element α i in GF(q) with 0 ≤ i < q − 1, its location vector z(α i ) is defined as a (q − 1)-tuple,
z(α i ) = (z 0 , z 1 , · · · , z q−1 ),(32)
with components corresponding to the q −1 nonzero elements, α 0 , α, · · · , α q−2 , of GF(q), where the i-th component z i = 1 and all the other q − 2 components are zeros. Note that the 0element of GF(q) is not included in formation of this location vector of a nonzero element in GF(q). The location vector of the 0-element of GF(q) is defined as the all-zero (q − 1)-tuple, (0, 0, ..., 0). Again consider the (q, 2, q − 1) extended RS code C b with two information symbols. It contains q(q − 1) codewords of weight q − 1. Each of these m-w codewords contains one and only one 0-component.
For i = −∞, 0, 1, · · · , q − 2, let v i = (v −∞ , v 0 , v 1 , · · · , v q−2 ) be a m-w codeword in C b with i-th component v i,i = 0. Let U i = {v i , αv i , · · · ,
α q−2 v i } be the set of q − 1 m-w codewords with the i-th components equal to zero. Then the q(q −1) m-w codewords can be partitioned into q subsets, U −∞ , U 0 , U 1 , · · · , U q−2 , each consisting of q − 1 m-w codewords. These sets are called uniform classes of m-w codewords in C b . Two m-w codewords in the same uniform class U i differ in all the q − 1 nonzero positions and they both have zeros at the i-th position. Two m-w codewords from two different classes differ in at least q − 1 positions.

For the i-th uniform class U i of m-w codewords, we form a (q−1)×q matrix G i over GF(q) with the q−1 m-w codewords in U i as rows,
G i =      v i αv i . . . α q−2 v i      (33) =      v i,−∞ v i,0 · · · v i,q−2 αv i,−∞ αv i,0 · · · αv i,q−2 · · · · · · . . . · · · α q−2 v i,−∞ α q−2 v i,0 · · · α q−2 v i,q−2      .
The i-th column of G i is a column of q − 1 zeros and any other column consists of q − 1 distinct nonzero entries which are the q − 1 nonzero elements of GF(q). It follows from the structural properties of the uniform classes of m-w codewords of the (q, 2, q − 2) extended RS code C b that any two rows in the same matrix G i differ in exactly q − 1 places and any two rows from two different matrices G i and G j differ in at least q − 1 places. Replacing each entry in G i by its location vector defined by (32), we obtain a row of q submatrices of size (q −1)×(q −1),
B i = [ A i,−∞ A i,0 · · · A i,q−2 ],(34)
where A i,i is a (q − 1) × (q − 1) zero matrix and all the other q − 1 submatrices A i,j 's are (q − 1) × (q − 1) circulant permutation matrices. Form the following q × q array of (q − 1) × (q − 1) circulant permutation and zero matrices:
H rs,3 =      B −∞ B 0 . . . B q−2      (35) =      A −∞,−∞ A −∞,0 · · · A −∞,q−2 A 0,−∞ A 0,0 · · · A 0,q−2 . . . . . . . . . . . . A q−2,−∞ A q−2,0 · · · A q−2,q−2      ,
where the submatrices, A −∞,−∞ , A 0,0 , · · · , A q−2,q−2 , on the main diagonal of H rs, 3 are zero matrices and the other submatrices are (q−1)×(q−1) circulant permutation matrices. H rs,3 is a q(q − 1) × q(q − 1) matrix over GF(2) with both column and row weights q − 1. It follows from the structural properties of matrices G i 's that no two rows (or two columns) of H rs,3 have more than one 1-component in common and hence it satisfies the RC-constraint. The associated Tanner graph of H rs,3 is free of cycles of length 4 and hence has a girth of at least 6. (2). If H rs,3 (d v , d c ) does not contain zero matrices on the main diagonal of H rs,3 , it is a regular matrix with column and row weights d v and d c , respectively. The null space of H rs, 3 
For 1 ≤ d v , d c ≤ q, let H rs,3 (d v , d c ) be a d v × d c subarray of H rs,3 . It is a d v (q − 1) × d c (q − 1) matrix over GF(d v , d c ) gives a (d v , d c )-regular RS-based QC-LDPC code of length d c (q −1) with minimum distance at least d v +2
for even d v and d v + 1 for odd d v , whose Tanner graph has a girth of at least 6. If with iterative decoding using the SPA with 50 iterations is shown in Fig. 23. At a BER of 10 −6 , it performs 1.55 dB from the Shannon limit. This code is the quasi-cyclic counterpart of the (2048, 1723) regular RS-based LDPC code given in Example 6 (or the standard code for the IEEE 802.3 10G Base-T Ethernet). Its encoding can be implemented with 6 shiftregister-adder-accumulator (SRAA) units [13], each consisting of 126 flip-flops, 64 two-input XOR gates and 64 two-input AND gates. The performance of this code is almost the same as that of the standard code for the IEEE 802.3 10G Base-T Ethernet.


## VII. MASKING

Given a d v × d c array of permutation matrices, H rs,e = [A i,j ] with e = 1, 2 or 3, a set of permutation matrices can be masked (i.e., replaced by zero matrices) to generate a new LDPC code. The masking operation can be modeled mathematically as a special matrix product [7] [57]. Let (2). Define the following matrix product:  (d v , d c ) is an array of permutation and zero matrices. The distribution of permutation matrices in M rs, 3 
W(d v , d c ) = [w i,j ] be a d v × d c matrix over GFM rs,e (d v , d c ) = W(d v , d c ) H rs,e (d v , d c ) = [w i,j A i,j ],(36)where w i,j A i,j = A i,j for w i,j = 1 and w i,j A i,j = 0 (a zero matrix) for w i,j = 0. With(d v , d c )
is identical to the distribution of 1-entries in the masking matrix W (d v , d c ).

It is clear that masking operation preserves the RCconstraint on the rows and columns of the base array H rs,e (d v , d c ) and hence the masked matrix M rs,e (d v , d c ) also satisfies the RC-constraint. Furthermore, masking reduces the density of 1-entries in the base matrix and therefore the masked matrix is a sparser matrix. Consequently, the associated Tanner graph of M rs,e (d v , d c ) has either a larger girth or a smaller number of short cycles than that of the base matrix. If the girth of the masking matrix is g > 6, then the girth of the Tanner graph of the masked matrix is at least g. Since the size of a masking matrix is in general not very large, it is quite easy to construct masking matrices with relatively large girth, say 8, 10 and 12, either by computer search or by the techniques given in [64] [65].

The null space of the masked matrix M rs,e (d v , d c ) gives an LDPC code C rs,e is an irregular LDPC code. Masking is an effective technique for constructing long structured regular and irregular LDPC codes. The performance of an LDPC code constructed by masking depends on the choice of the masking matrix. Regular masking matrices can be constructed using algebraic or combinatorial methods. An irregular masking matrix can be constructed by computer search based on the variable-and check-node degree distributions of a code's Tanner graph derived by the evolution of the probability densities of the messages passed between the two types of nodes in a belief propagation decoder as proposed in [66].

Example 9: In this example, we choose the (257, 2, 256) extended RS code over GF(257) as the base code C b for code construction. Using the method given in Section VI-B, a 257 × 257 array H rs, 3 (8,64) gives a (16384, 14337) regular RS-based QC-LDPC code with rate 0.875. The performance of this code with iterative decoding using the SPA is shown in Fig. 24. At a BER of 10 −6 , it performs 0.85 dB from the Shannon limit.  An irregular LDPC code is given by the null space of a sparse matrix H with varying column weights and/or varying row weights so that the code's Tanner graph has varying nodal degrees. The nodal degree distributions (hence, row/column weight distributions) from the node perspective (see Example 1) are expressed in terms of two polynomials [66], v(
X) = d v i=1 v i X i−1 and c(X) = d c i=1 c i X i−1 ,
where v i and c i denote the fractions of variable-and check-node with degree i, respectively, d v and d c denote the maximum variable-and check-node degrees, respectively. Irregular LDPC codes can be constructed based on the degree distributions of a code graph and masking an array of permutation matrices. First we design the degree distributions, v(X) and c(X), of the variable-and check-nodes of the graph of a code of rate R based on EXIT charts (or density evolution [16]). Then choose proper parameters, d v , d c and q (or p) that will give us the desired code length and rate R,where d v ≥ d v and d c ≥ d c . By computer search, we construct a masking matrix W(d v , d c ) that has column and row weight distributions identical (or close) to v(X) and c(X). Construct a base array H rs,e (d v , d c ) with e = 1, 2 or 3 using a method described above. Masking the base matrix H rs,e (d v , d c ) by W(d v , d c ), we obtain a masked matrix M rs,e (d v , d c ) which has column and row weight distributions identical (or close) to v(X) and c(X). This masking not only gives a structured irregular LDPC code but also simplifies the code construction. Since the Tanner graph of the base matrix H rs,e (d v , d c ) is already free of cycles of length 4, the Tanner graph of the resultant irregular LDPC code is also free of cycles of length 4 and hence has a girth of at least 6. By contrast, in random construction, a large random bipartite graph based on the degree distributions must first constructed. In the process of constructing a code graph by computer, effort must be made to avoid cycles of length 4, which may not be easy.

Since optimal degree distributions for a given code rate are derived based on the assumptions of infinite code length, cycle-free code graph, and an infinite number of decoding iterations. When applied to construct short codes, the optimal degree distributions are no longer optimal any more and they usually result in an irregular code with a high error-floor. Therefore, proper adjustment of the degree distributions must be made to achieve good performance.

Example 10: The following degree distributions of variable-and check-nodes of a bipartite graph are designed for a code with rate 1/2 and length between 4000 and 5000: v(X) = 0.25X + 0.625X 2 + 0.125X 8 and c(X) = X 6 .  (32,64) from H rs,2 as the base array for masking. It is a 2336 × 4672 matrix over GF(2) with column and row weights 32 and 64, respectively. Construct a masking matrix W(γ, ρ) by computer search with column and row weight distributions close to the degree distributions v(X) and c(X) given above. Masking the base array H rs,2 (32,64) with W(32, 64), we obtain a masked 32 × 64 array M rs,2 (32,64) of circulant permutation and zero matrices. The column and row weight distributions of M rs,2 (32,64) are identical to v(X) and c(X). The null space of M rs,2 (32, 64) gives a (4672, 2336) irregular RS-based QC-LDPC code. The performance of this code with iterative decoding using the SPA (50 iterations) is shown in Fig. 25. The code performs very well: at a BER of 10 −6 , it is 1.6 dB from the Shannon limit.


## VIII. CONCLUSION AND OPEN PROBLEMS

This paper provided fundamentals in the design of LDPC codes. The EXIT chart technique for determining near-optimal degree distributions for LDPC code ensembles was first discussed to provide a target for the code designer. The utility of representing codes by protographs and how this naturally leads to quasi-cyclic LDPC codes was also discussed, after which the EXIT chart technique was extended to the special case of protograph-based LDPC codes. Discussed next was several design approaches for LDPC codes which incorporate one or more accumulators, including quasi-cyclic accumulatorbased codes. The second half the paper then switched to several algebraic LDPC code design techniques including codes based on finite geometries and codes whose designs are based on Reed-Solomon codes. The algebraic designs lead to cyclic, quasi-cyclic, and structured codes. Finally, the masking technique for converting regular quasi-cyclic LDPC codes to irregular codes was presented. While the paper focuses on the BI-AWGNC, as discussed in the paper, good BI-AWGNC codes tend to be universally good across many channels.

The ultimate goal in the LDPC code field is a situation that is analog of BCH or RS codes, that is, a straightforward design technique and a straightforward performance analysis. While this may be possible someday, in the short term, some of the open problems that are undergoing studies by researchers are as follows. It is well known that error-floors can be due to a small minimum distance or it can be the fault of the iterative decoder. Thus, there is a tremendous amount of research being undertaken to understand the floor phenomenon. Another issue is the design of short codes. As mentioned in Section II, decoding threshold prediction techniques assume an infinite codeword length and an infinite number of decoding iterations. This leads one to ask about threshold prediction for short codes with a finite number of iterations. Another problem being studied is generalized LDPC codes in which the single parity-check nodes and repetition nodes of Tanner graphs were replaced by more complex constraints. This was first considered by Tanner [2]. Other problems include lower bounding the minimum distance of an LDPC code and understanding the impact of cycle structure and distribution on an iterative decoder. After receiving the Ph.D. degree Prof. Ryan held positions in industry for five years, first at The Analytic Sciences Corporation, then at Ampex Corporation, and finally at Applied Signal Technology. From 1993 to 1998, he was an assistant professor and then associate professor in the Department of Electrical and Computer Engineering at New Mexico State University, Las Cruces, NM. From 1998 to present, he has been on the faculty in the Department of Electrical and Computer Engineering at the University of Arizona, Tucson, AZ, first as an associate professor and then as full professor.

Prof. Ryan has over 75 publications in the leading conferences and journals in the area of communication theory and channel coding. He is also preparing the textbook Iteratively Decodable Codes: Construction and Decoding (Shu Lin, co-author) to be published by Cambridge University Press. His research interests are in coding and signal processing with applications to magnetic data storage and wireless data communications. He was an associate editor for the IEEE Transactions on Communications from 1998 through 2005. He is a Senior Member of the IEEE.

## Fig. 1 .
1Tanner graph representation of LDPC codes.

## Fig. 2 .
2EXIT chart example for (d v , d c ) = (3, 6) regular LDPC code.

## Fig. 3 .
3EXIT chart for rate-1/2 irregular LDPC code. (Ack: S. AbuSurra)

## Fig. 4 .
4Illustration of the protograph copy and permute procedure with q = 4 copies.


equals zero when x i is punctured and equals the selected E b /N 0 otherwise. 2) VN to CN. For i = 0, . . . , N − 1 and j = 0, . . . , M − 1, compute (11). 3) CN to VN. For i = 0, . . . , N − 1 and j = 0, . . . , M − 1, compute (12). 4) Cumulative mutual information. For i = 0, . . . , N − 1, compute

## Fig. 5 .
5Tanner graph (a) and encoder (b) for irregular repeat-accumulate codes.


For IRA codes, H u has column weights {d b,i } and row weights {d c,j }. The encoder of Fig. 5(b) is obtained by noting that the generator matrix corresponding to H in (13) is G = I H T u H −T p and writing H u as Π T A T , where Π is a permutation matrix. Note also that H −T p performs the same computation as 1/(1 ⊕ D) (and H −T p

## Fig. 6 .
6Performance of a (2044,1024) S-IRA code on the BI-AWGNC. HW=hardware simulator. SW=software simulator.

## Fig. 7 .
7IRAA encoder.

## Fig. 8 .
8Rate-1/2 SIRA and SIRAA protographs for the codes in


) The IRAA codeword can be either c = [u p] or c = [u b p], depending on whether the intermediate parity bits b are punctured or not. The parity-check matrix of the general IRAA code corresponding to Fig. 7 is

## Fig. 9 .
9Performance comparison between rate-1/2 S-IRA and S-IRAA codes on the BI-AWGNC, n = 2048 and k = 1024.

## Fig. 10 .
10Rate-1/3 SIRA and SIRAA protographs for the codes in Fig. 11. SIR: (E b /N 0 ) thres = 0.40 dB. SIRAA: (E b /N 0 ) thres = 0.83 dB.

## Fig. 11 .
11Performance comparison between rate-1/3 S-IRA and S-IRAA codes on the BI-AWGNC, n = 3072 and k = 1024.

## Fig. 12 .
12Generic bipartite graph for ARA codes.

## Fig. 13 .
13AR4A protographs in (a) serial-concatenated form and (b) parallelconcatenated form. (E b /N 0 ) thres = 0.55 dB.

## Fig. 14 .
14H matrix for the (2048,1024) AR4A code.

## Fig. 15 .
15BER and FER performance for an AR4A code.

## Fig. 16 .
16Node convergence analysis for a (2048,1024) AR4A code at E b /N 0 = 2.25 dB. modulation formats. A further level of protection is afforded by an outer BCH code.


[51][52], denoted by EG(m, q), consists of q m points, and each point is represented by an m-tuple over GF(q). The point represented by the all-zero m-tuple 0 = (0, 0, . . . , 0), is called the origin of the geometry. A line in EG(m, q) is either a one-dimensional subspace of the vector space of all the m-tuples over GF(q), or a coset of it. There are q m−1 (q m − 1)/(q − 1) lines in total. Each line consists of q points. Two points are connected by one and only one line. If a is a point on the line L, we say that the line L passes through the point a. Two lines either do not have any point in common or they have one and only one point in common. If two lines have a common point a, we say that they intersect at a. For any point a in EG(m, q), there are exactly (q m − 1)/(q − 1) lines passing through (or intersecting at) a. In particular, if a is not the origin, then it lies on q(q m−1 −1)/(q −1) lines not passing through the origin. Furthermore, there are in total (q m−1 − 1)(q m − 1)/(q − 1) lines not passing through the origin.The extension field GF(q m ) of GF(q) is a realization of EG(m, q) [7][51]. Let α be a primitive element of GF(q m ).

## Fig. 17 .
17Performance of the binary (4095,3367) cyclic EG-LDPC code given in Example 4 over the BI-AWGNC.


m,q),k be the transpose of H(e) PG(m,q),k with e = 1 or 2. Then the null space of H (e)

## Fig. 18 .Fig. 19 .
1819Performance of the binary (3510,3109) quasi-cyclic PG-LDPC code given in Example 5 over the BI-AWGNC. Performance of the binary (4095,3367) EG-LDPC code given in Example 4 with various decoding techniques over the BI-AWGNC. MLD = majority-logic decoding. BF = bit-flipping. SPA = sum-product algorithm.


over GF(2) with column and row weights d v and d c , respectively. It is a (d v , d c )-regular matrix which also satisfies the RC-constraint. The null space of H rs,1 (d v , d c ) gives a (d v , d c )-regular RS-based LDPC code C rs,1 of length d c q with rate at least (d c −d v )/d c and minimum distance at least d v + 1 [50],

## Example 6 :
6Consider the (64, 2, 63) extended RS code C b over GF(2 6  ). Based on the codewords of this RS code C b , we can construct a 64 × 64 array H rs,1 of 64 × 64 permutation matrices. Suppose we choose d v = 6 and d c = 32. Take a 6 × 32 subarray H rs,1 (6, 32) from H rs,1 , say the 6 × 32 subarray at the upper left corner of H rs,1 .

## Fig. 20 .
20Performance of the binary (2048,1723) regular RS-based LDPC code given in Example 6 over the BI-AWGNC.

## Fig. 21 .Fig. 22 .
2122Performance of the binary (5256,4895) regular RS-based QC-LPDC code given in Example 7 over the BI-AWGNC. The decoding convergence rate of the (5256,4895) QC-LDPC code given in Example 7. polynomials of degree 1 or less over GF(73). Using this base RS code, we can construct a 73 × 73 array H rs,2 of 73 × 73 circulant permutation matrices. Choose d v = 5 and d c = 72. Take a 5 × 72 subarray H rs,2 (5, 72) from H rs,2 . H rs,2 (5, 72) is a 365 × 5256 matrix over GF(2) with column and row weights 5 and 72, respectively. The null space of H rs,2(5, 72)   

## Fig. 23 .
23H rs,3 (d v , d c ) contains some zero matrices of H rs,3 , then it has two column weights d v − 1 and d v and may have two row weights d c − 1 and d c . In this case, the null space of H rs,3 (d v , d c ) gives a near regular QC-LDPC code. The above construction gives another class of RS-based QC-LDPC codes. Example 8: Suppose the (64, 2, 63) extended RS code over GF(2 6 ) is used as the base code C b for constructing QC-LDPC codes. Based on the m-w codewords of this base code, we can construct a 64×64 array H rs,3 of 63×63 circulant permutation and zero matrices. Set d v = 6 and d c = 32. Take a 6 × 32 subarray H rs,3 (6, 32) from H rs,3 , avoiding the zero matrices. Then H rs,3 (6, 32) is a 378 × 2016 matrix over GF(2) with column and row weights 6 and 32, respectively. The null space of H rs,3 (6, 32) gives a (2016, 1692) regular RS-based QC-LDPC code with rate 0.8392. The performance of this code Performance of the binary (2016,1692) QC-LDPC code given in Example 8 over the BI-AWGNC.


,e with girth at least 6. For e = 2 or 3, C(m)rs,e is a QC-LDPC code. If the masking matrix is a regular matrix with constant column and row weights, then C(m)rs,e is a regular LDPC code. If the masking matrix has varying column and row weights, then C (m)

## g 1 =
1(10011010) g 2 = (11011000) g 3 = (00111010) g 4 = (01100110) g 5 = (01111000) g 6 = (11100010) g 7 = (11010010) g 8 = (01010110)

## Fig. 24 .
24Performance of the binary (16384,14337) QC-LDPC code given in Example 9 over the BI-AWGNC.

## Fig. 25 .
25Performance of the binary (4672,2336) QC-LDPC code given in Example 10 over the BI-AWGNC. The average variable-node and check-node degrees are 3.5 and 7, respectively. Suppose we want to construct a code of length about 4600. To construct such a code, we choose the (73, 2, 72) RS code C b over GF(73) as the base code and construct a 73 × 73 array H rs,2 of 73 × 73 circulant permutation matrices based on the method presented in Section VI-A. Choose d v = 32 and d c = 64. Take a 32 × 64 subarray H rs,2

## Gianluigi
Liva was born in Spilimbergo, Italy. He received the M.S. degree in Electrical Engineering, in 2002, and the Ph.D. degree, in 2006, from the University of Bologna, Bologna, Italy. He is currently working at the Institute of Communications and Navigation of the German Aerospace Center (DLR) in Munich. His research interests include the design and the analysis of error correcting codes based on sparse graphs for space communication systems. Shumei Song was born in Henan, China. She received the B.S.E.E. degree from Tsinghua University, Beijing, China, in 2000, and the M.S.E.E degree from Peking University, Beijing, China, in 2003. She is currently working toward the Ph.D degree in communication and coding theory at the University of California, Davis. Lan Lan received the B.E. and M.E. degrees from the University of Electronic Science and Technology of China, Chengdu, China, in 1998 and 2001, and the Ph.D. degree in electrical engineering from the University of California, Davis, in 2006. She is currently working for Keyeye communications company as a DSP design engineer. Her research interests include error-control coding techniques and their application in digital communications and digital storage systems. Yifei Zhang received the B.E. and M.E. degrees in electrical and communication systems from Beijing University of Posts and Telecommunications, Beijing, China, in 1998 and 2001, respectively. She is currently working toward the Ph.D. degree in the Department of Electrical and Computer Engineering, University of Arizona, Tucson. Her research interests include error-control coding and its implementation for digital communications and data storage systems. Shu Lin (S'62-M'65-SM'78-F'80-LF'00) received the B.S.E.E. degree from the National Taiwan University, Taipei, Taiwan, in 1959, and the M.S. and Ph.D. degrees in electrical engineering from Rice University, Houston, TX, in 1964 and 1965, respectively. In 1965, he joined the Faculty of the University of Hawaii, Honolulu, as an Assistant Professor of Electrical Engineering. He became an Associate Professor in 1969 and a Professor in 1973. In 1986, he joined Texas A&M University, College Station, as the Irma Runyon Chair Professor of Electrical Engineering. In 1987, he returned to the University of Hawaii. From 1978 to 1979, he was a Visiting Scientist at the IBM Thomas J. Watson Research Center, Yorktown Heights, NY, where he worked on error control protocols for data communication systems. He spent the academic year of 1996-1997 as a Visiting Professor at the Technical University of Munich, Munich, Germany. He retired from University of Hawaii in 1999 and he is currently an Adjunct Professor at University of California, Davis. He has published numerous technical papers in IEEE TRANSACTIONS and other refereed journals. He is the author of the book, An Introduction to Error-Correcting Codes (Englewood Cliff, NJ: Prentice-Hall, 1970). He also co-authored (with D. J. Costello) the book, Error Control Coding: Fundamentals and Applications (Upper Saddle River, NJ: Prentice-Hall, 1st edition, 1982, 2nd edition, 2004), and (with T. Kasami, T. Fujiwara, and M. Fossorier) the book, Trellises and Trellis-Based Decoding Algorithms, (Boston, MA: Kluwer Academic, 1998). His current research areas include algebraic coding theory, coded modulation, error control systems, and satellite communications. He has served as the Principle Investigator on 32 research grants. Dr. Lin is a Member of the IEEE Information Theory Society and the Communication Society. He served as the Associate Editor for Algebraic Coding Theory for the IEEE TRANSACTIONS ON INFORMATION THEORY from 1976 to 1978, and as the Program Co-Chairman of the IEEE International Symposium of Information Theory held in Kobe, Japan, in June 1988. He was the President of the IEEE Information Theory Society in 1991. In 1996, he was a recipient of the Alexander von Humboldt Research Prize for U.S. Senior Scientists and a recipient of the IEEE Third-Millennium Medal, 2000. William E. Ryan received the Ph.D. degree in electrical engineering from the University of Virginia (Charlottesville, VA) in 1988 after receiving the B.S. and M.S. degrees from Case Western Reserve University and the University of Virginia, respectively, in 1981 and 1984.


received July 04, 2006; revised August 25, 2006. This work was supported by the University of Bologna, NASA-Goddard, and NSF. This paper has been approved by F. Chiaraluce. Gianluigi Liva is with the University of Bologna (email: gliva@deis.unibo.it). Shumei Song, Lan Lan, and Shu Lin are with the University of California at Davis (e-mail: ssmsong@ece.ucdavis.edu, squashlan@gmail.com, shulin@ece.ucdavis.edu). Yifei Zhang and William E. Ryan are with the University of Arizona, U.S.A. (e-mail: {yifeiz, ryan}@ece.arizona.edu).


this operation, a set of permutation matrices in H rs,e (d v , d c ) is masked by the 0-entries of W(d v , d c ). We call W(d v , d c ) the masking matrix, H rs,e (d v , d c ) the base array (or base matrix), and M rs,e (d v , d c ) the masked array (or matrix). The masked matrix M rs,e


of 256 × 256 circulant permutation matrices can be constructed based on the minimum weight codewords of C b . Choose d v = 8 and d c = 64. Take a 8 × 64 subarray H rs,3 (8, 64) from H rs,3 (avoiding zero matrices) as the base array for masking. Construct an 8 × 64 masking matrix W(8, 64) that consists of a row of eight 8 × 8 circulant matrices whose generators (top rows) are given inTable 1. W(8, 64) has column and row weights 4 and 32, respectively. Masking the base array H rs,3(8,16) with W(8, 64), we obtain a 2048 × 16384 regular masked matrix M rs,3(8,64) with column and row weights 4 and 32, respectively. The null space of M rs,3 

## TABLE I .
IGENERATORS OF CIRCULANTS IN THE MASKING MATRIX OF EXAMPLE 9.
Acknowledgment to C. Jones of JPL for simulating this code for us on an FPGA decoder.

Low density parity-check codes. R G Gallager ; Also, R G Gallager, Low-Density Parity-Check Codes. Cambridge, MAM.I.T. PressR. G. Gallager, Low-Density Parity-Check Codes, M.I.T. Press, Cam- bridge, MA, 1963. (Also, R. G. Gallager, "Low density parity-check codes," IRE Trans. Inform. Theory, IT-8, pp. 21-28, Jan. 1962.)

A recursive approach to low complexity codes. R M Tanner, IEEE Trans. Inform. Theory. 27R. M. Tanner, "A recursive approach to low complexity codes," IEEE Trans. Inform. Theory, vol. 27, pp. 533-547, Sept. 1981.

Good codes based on very sparse matrices. D Mackay, R Neal, Lecture Notes in Computer Science. C. BoydCryptography and Coding, 5th IMA ConfD. MacKay and R. Neal, "Good codes based on very sparse matrices," Cryptography and Coding, 5th IMA Conf., C. Boyd, Ed., Lecture Notes in Computer Science, Oct. 1995.

A linear time erasure-resilient code with nearly optimal recovery. N Alon, M Luby, IEEE Trans. Inform. Theory. 42N. Alon and M. Luby, "A linear time erasure-resilient code with nearly optimal recovery," IEEE Trans. Inform. Theory, vol. 42, pp. 1732-1736, Nov. 1996.

A digital fountain approach to reliable distribution of bulk data. J Byers, M Luby, M Mitzenmacher, A Rege, Proc. ACM SIGCOMM '98. ACM SIGCOMM '98Vancouver, BC, CanadaJ. Byers, M. Luby, M. Mitzenmacher, and A. Rege, "A digital fountain approach to reliable distribution of bulk data," Proc. ACM SIGCOMM '98, Vancouver, BC, Canada, Jan. 1998, pp. 56-67.

Good Error-Correcting Codes Based on Very Sparse Matrices. D J C Mackay, IEEE Trans. Inform. Theory. 452D. J. C. MacKay, "Good Error-Correcting Codes Based on Very Sparse Matrices," IEEE Trans. Inform. Theory, vol. 45, no. 2, pp. 399-431, 1999.

S Lin, D J Costello, Jr , Error Control Coding: Fundamentals and Applications. Upper Saddle River, NJPrentice-Hall2nd editonS. Lin and D. J. Costello, Jr., Error Control Coding: Fundamentals and Applications, 2nd editon, Prentice-Hall, Upper Saddle River, NJ., 2004.

CRC Handbook for Coding and Signal Processing for Recording Systems. W E Ryan, ; E Kurtas, CRC PressAn Introduction to LDPC CodesW. E. Ryan, "An Introduction to LDPC Codes," CRC Handbook for Coding and Signal Processing for Recording Systems, Ed., B. Vasic and E. Kurtas, CRC Press, 2004.

The universality of LDPC codes on wireless channels. C Jones, A Matache, T Tian, J Villasenor, R Wesel, Proc. Military Comm. Conf. (MILCOM). Military Comm. Conf. (MILCOM)C. Jones, A. Matache, T. Tian, J. Villasenor, R. Wesel, "The universality of LDPC codes on wireless channels," in Proc. Military Comm. Conf. (MILCOM), Oct. 2003.

Does the performance of LDPC codes depend on the channel. M Franceschini, G Ferrari, R Raheli, Proc. Int. Symp. Inf. Theory and its Applns. Int. Symp. Inf. Theory and its ApplnsM. Franceschini, G. Ferrari, and R. Raheli, "Does the performance of LDPC codes depend on the channel?" in Proc. Int. Symp. Inf. Theory and its Applns, 2004.

Extrinsic information transfer functions: Model and erasure channel properties. A Ashikhmin, G Kramer, S Brink, IEEE Trans. Inform. Theory. 50A. Ashikhmin, G. Kramer, and S. ten Brink, "Extrinsic information transfer functions: Model and erasure channel properties," IEEE Trans. Inform. Theory, vol. 50, pp. 2657-2673, Nov. 2004.

Surrogate channel design of universal LDPC codes. F Peng, W E Ryan, R D Wesel, IEEE Commun. Letters. 10F. Peng and W. E. Ryan and R. D. Wesel, "Surrogate channel design of universal LDPC codes," IEEE Commun. Letters, vol. 10, pp. 480-482, Jun. 2006.

Efficient encoding of low-density parity-check codes. Z Li, L Chen, L Zeng, S Lin, W Fong, IEEE Trans. Commun. 54Z. Li, L. Chen, L. Zeng, S. Lin, and W. Fong, "Efficient encoding of low-density parity-check codes," IEEE Trans. Commun., vol. 54, pp. 71-81, Jan. 2006.

Convergence Behavior of Iteratively Decoded Parallel Concatenated Codes. S Brink, IEEE Trans. Commun. 49S. ten Brink, "Convergence Behavior of Iteratively Decoded Parallel Concatenated Codes," IEEE Trans. Commun., vol. 49, pp. 1727-1737, Oct. 2001.

Design of low-density parity-check codes for modulation and detection. S Brink, G Kramer, A Ashikhmin, IEEE Trans. Commun. 52S. ten Brink, G. Kramer, and A. Ashikhmin, "Design of low-density parity-check codes for modulation and detection," IEEE Trans. Com- mun., vol. 52, pp. 670-678, Apr. 2004.

Design of capacityapproaching irregular low-density parity-check codes. T Richardson, A Shokrollahi, R Urbanke, IEEE Trans. Information Theory. 47T. Richardson, A. Shokrollahi, and R. Urbanke, "Design of capacity- approaching irregular low-density parity-check codes," IEEE Trans. Information Theory, vol. 47, pp. 619-637, Feb. 2001.

Iterative Turbo Decoder Analysis Based on Density Evolution. D Divsalar, S Dolinar, F Pollara, IEEE Journal on Selected Areas in Communications. 19D. Divsalar, S. Dolinar, and F. Pollara, "Iterative Turbo Decoder Analysis Based on Density Evolution," IEEE Journal on Selected Areas in Communications, vol. 19, pp. 891-907, May, 2001.

Analyzing the Turbo Decoder Using the Gaussian Approximation. H El Gamal, A R Hammons, IEEE Trans. Inform. Theory. 472H. El Gamal and A. R. Hammons, "Analyzing the Turbo Decoder Using the Gaussian Approximation," IEEE Trans. Inform. Theory, vol. 47, no. 2, pp. 671-686, Feb. 2001.

A More Accurate One-Dimensional Analysis and Design of LDPC codes. M Ardakani, F R Kschischang, IEEE Trans. on Comm. M. Ardakani and F. R. Kschischang, "A More Accurate One- Dimensional Analysis and Design of LDPC codes," IEEE Trans. on Comm., Dec. 2004, pp 2106-2114.

Measures for tracing convergence of iterative decoding algorithms. M Tüchler, S Brink, J Hagenauer, Proc. 4th IEEE/ITG Conf.on Source and Channel Coding. 4th IEEE/ITG Conf.on Source and Channel CodingBerlin, GermanyM. Tüchler, S. ten Brink, and J. Hagenauer, "Measures for tracing convergence of iterative decoding algorithms," Proc. 4th IEEE/ITG Conf.on Source and Channel Coding, Berlin, Germany, Jan. 2002.

EXIT functions for the Gaussian channel. E Sharon, A Ashikhmin, S Litsyn, Proc. 40th Annu. Allerton Conf. Communication, Control, Computers. 40th Annu. Allerton Conf. Communication, Control, ComputersAllerton, ILE. Sharon, A. Ashikhmin, and S. Litsyn, "EXIT functions for the Gaussian channel," Proc. 40th Annu. Allerton Conf. Communication, Control, Computers, Allerton, IL, Oct. 2003, pp. 972-981.

EXIT functions for continuous channels -Part I: Constituent codes. E Sharon, A Ashikhmin, S Litsyn, IEEE Trans. Commun. submittedE. Sharon, A. Ashikhmin, and S. Litsyn, "EXIT functions for continuous channels -Part I: Constituent codes," submitted, IEEE Trans. Commun.

Design of repeat-accumulate codes for iterative detection and decoding. S Brink, G Kramer, IEEE Trans. Sig. Proc. 51S. ten Brink and G. Kramer, "Design of repeat-accumulate codes for iterative detection and decoding," IEEE Trans. Sig. Proc., vol. 51, pp. 2764-2772, Nov. 2003.

On quasi-cyclic repeat-accumulate codes. R , Michael Tanner, Proc. 37th Allerton Conf. on Communication, Control, and Computing. 37th Allerton Conf. on Communication, Control, and ComputingR. Michael Tanner, "On quasi-cyclic repeat-accumulate codes," in Proc. 37th Allerton Conf. on Communication, Control, and Computing, Sept. 1999.

Construction of low-density parity-check codes by superposition. Jun Xu, Lei Chen, Lingqi Zeng, Lan Lan, Shu Lin, IEEE Trans. Commun. 53Jun Xu, Lei Chen, Lingqi Zeng, Lan Lan, and Shu Lin, "Construction of low-density parity-check codes by superposition," IEEE Trans. Com- mun., vol. 53, pp. 243-251, Feb. 2005.

Multi-edge type ldpc codes. T J Richardson, R L Urbanke, IEEE Trans. Inf. Theory. to appearT. J. Richardson and R. L. Urbanke, "Multi-edge type ldpc codes," to appear, IEEE Trans. Inf. Theory. [Online]. Available: http://lthcwww.epfl.ch/

Low-Density Parity-Check (LDPC) Codes Constructed from Protographs. J Thorpe, JPL INP. Tech. Rep.J. Thorpe, "Low-Density Parity-Check (LDPC) Codes Constructed from Protographs," JPL INP, Tech. Rep., Aug. 2003, 42-154.

Design of VLSI implementation-oriented LDPC codes. H Zhong, T Zhang, Proc. 58th Vehicular Technology Conf. 58th Vehicular Technology ConfH. Zhong and T. Zhang "Design of VLSI implementation-oriented LDPC codes," in Proc. 58th Vehicular Technology Conf., Oct. 2003, pp. 670-673.

High-performance decoders for regular and irregular repeat-accumulate codes. M M Mansour, Proc. IEEE GLOBECOM. IEEE GLOBECOMM. M. Mansour, "High-performance decoders for regular and irregular repeat-accumulate codes," in Proc. IEEE GLOBECOM, Nov. 29-Dec. 3, 2004, pp. 2583-2588.

Block Codes Based on Sparse Graphs for Wireless Communication Systems. G Liva, Bologna, ItalyUniversità degli Studi diPh.D. thesisG. Liva, Block Codes Based on Sparse Graphs for Wireless Communi- cation Systems, Ph.D. thesis, Università degli Studi di Bologna, Italy, 2006.

Extrinsic information transfer analysis for protograph-based LDPC codes. G Liva, M Chiani, IEEE Trans. Comm. submittedG. Liva and M. Chiani, "Extrinsic information transfer analysis for protograph-based LDPC codes", submitted, IEEE Trans. Comm., 2006.

Coding theorems for Turbolike codes. D Divsalar, H Jin, R J Mceliece, Proc. 36th Allerton Conf. on Communication, Control, and Computing. 36th Allerton Conf. on Communication, Control, and ComputingAllerton, IllinoisD. Divsalar, H. Jin, and R. J. McEliece, "Coding theorems for Turbo- like codes," in Proc. 36th Allerton Conf. on Communication, Control, and Computing, Allerton, Illinois, Sept. 1998, pp. 201-210.

Irregular repeat-accumulate codes. H Jin, A Khandekar, R Mceliece, Proc. International Symposium on Turbo codes and Related Topics. International Symposium on Turbo codes and Related TopicsH. Jin, A. Khandekar, and R. McEliece, "Irregular repeat-accumulate codes," in Proc. International Symposium on Turbo codes and Related Topics, Sept. 2000, pp. 1-8.

Design and performance evaluation of some high-rate irregular low-density parity-check codes. M Chiani, A Ventura, Proc. IEEE Globecom. IEEE GlobecomM. Chiani and A. Ventura, "Design and performance evaluation of some high-rate irregular low-density parity-check codes, Proc. IEEE Globecom, Nov. 2001.

Design of efficiently encodable moderate-length high-rate irregular LDPC codes. M Yang, Y Li, W E Ryan, IEEE Trans. Commun. 52M. Yang, Y. Li, and W. E. Ryan, "Design of efficiently encodable moderate-length high-rate irregular LDPC codes," IEEE Trans. Com- mun., vol. 52, pp. 564-571, Apr. 2004.

Structured IRA Codes: Performance Analysis and Construction. Y Zhang, W E Ryan, IEEE Trans. Commun. to appearY. Zhang and W. E. Ryan, "Structured IRA Codes: Performance Analysis and Construction," IEEE Trans. Commun., 2006, to appear.

Progressive edge-growth Tanner graphs. Xiao , Yu Hu, Evangelos Eleftheriou, Dieter Michael Arnold, Proc. 2001 GlobeCom Conf. 2001 GlobeCom ConfSan Antonio, TexasXiao Yu Hu and Evangelos Eleftheriou and Dieter Michael Arnold, "Progressive edge-growth Tanner graphs," Proc. 2001 GlobeCom Conf., San Antonio, Texas, Nov. 2001, pp. 995-1001.

Characterization and selective avoidance of cycles in irregular LDPC codes. T Tian, C Jones, J Villasenor, R D Wesel, Proc. ICC'03. ICC'03T. Tian and C. Jones and J. Villasenor and R. D. Wesel, "Characterization and selective avoidance of cycles in irregular LDPC codes," in Proc. ICC'03, May, 2003.

Quasi-Cyclic Low-Density Parity-Check Codes From Circulant Permutation Matrices. M Fossorier, IEEE Trans. Inf. Theory. 50M. Fossorier, "Quasi-Cyclic Low-Density Parity-Check Codes From Circulant Permutation Matrices," IEEE Trans. Inf. Theory, vol. 50., Aug. 2004, pp. 1788-1793.

Simple Reconfigurable Low-Density Parity-Check Codes. G Liva, E Paolini, M Chiani, IEEE Commun. Letters. 9G. Liva, E. Paolini, and M. Chiani, "Simple Reconfigurable Low- Density Parity-Check Codes," IEEE Commun. Letters, vol. 9, pp. 258- 260, March, 2005

Constructions for irregular repeataccumulate codes. S J Johnson, S R Weller, Proc. IEEE Int. Sym. Inform. Theory. IEEE Int. Sym. Inform. TheoryAdelaideS. J. Johnson and S. R. Weller, "Constructions for irregular repeat- accumulate codes," in Proc. IEEE Int. Sym. Inform. Theory, Adelaide, Sept. 2005.

Design of variable-rate irregular LDPC codes with low error floor. L Dinoi, F Sottile, S Benedetto, IEEE Int. Conf. Comm. L. Dinoi, F. Sottile, and S. Benedetto, "Design of variable-rate irregular LDPC codes with low error floor," 2005 IEEE Int. Conf. Comm., May 2005.

Design methods for irregular repeat-accumulate codes. A Roumy, S Guemghar, G Caire, S Verdu, IEEE Trans. Inform. Theory. 50A. Roumy, S. Guemghar, G. Caire, and S. Verdu, "Design methods for irregular repeat-accumulate codes," IEEE Trans. Inform. Theory, vol. 50, pp. 1711-1727, Aug. 2004.

Structured eIRA codes. Y Zhang, W E Ryan, Y Li, Proc. 38th IEEE Asilomar Conf. on Signals, Systems, and Computers. 38th IEEE Asilomar Conf. on Signals, Systems, and ComputersPacific Grove, CAY. Zhang, W. E. Ryan, and Y. Li, "Structured eIRA codes," in Proc. 38th IEEE Asilomar Conf. on Signals, Systems, and Computers, Pacific Grove, CA, Nov. 2004, pp. 7-10.

Accumulate Repeat Accumulate Codes. A Abbasfar, K Yao, D Disvalar, Proc. IEEE GLOBECOM. IEEE GLOBECOMDallas, TexasA. Abbasfar, K. Yao, and D. Disvalar, "Accumulate Repeat Accumulate Codes," in Proc. IEEE GLOBECOM, Dallas, Texas, Nov. 2004.

Constructing LDPC codes from simple loop-free encoding modules. D Divsalar, S Dolinar, J Thorpe, C Jones, Proc. IEEE International Conference on Communications. IEEE International Conference on CommunicationsD. Divsalar, S. Dolinar, J. Thorpe, and C. Jones, "Constructing LDPC codes from simple loop-free encoding modules," in Proc. IEEE Inter- national Conference on Communications, May 2005.

Protograph based LDPC codes with minimum distance linearly growing with block size. D Divsalar, C Jones, S Dolinar, J Thorpe, Proc. IEEE GLOBECOM. IEEE GLOBECOMD. Divsalar, C. Jones, S. Dolinar, and J. Thorpe, "Protograph based LDPC codes with minimum distance linearly growing with block size," in Proc. IEEE GLOBECOM, Nov. 2005.

Second generation framing structure, channel coding and modulation systems for Broadcasting, Interactive Services, News Gathering and other broadband satellite applications, ETSI. EN. 302307Second generation framing structure, channel coding and modulation systems for Broadcasting, Interactive Services, News Gathering and other broadband satellite applications, ETSI, EN 302 307, 2004.

Accumulate-repeat-accumulateaccumulate-codes. D Divsalar, S Dolinar, J Thorpe, Proc. 60th Vehicular Technology Conf. 60th Vehicular Technology ConfD. Divsalar, S. Dolinar, and J. Thorpe, "Accumulate-repeat-accumulate- accumulate-codes", Proc. 60th Vehicular Technology Conf., Sept. 2004, pp. 2292-2296.

Low density parity check codes based on finite geometries: a rediscovery and new results. Y Kou, S Lin, M Fossorier, IEEE Trans. Inform. Theory. 4711Y. Kou, S. Lin, and M. Fossorier, "Low density parity check codes based on finite geometries: a rediscovery and new results," IEEE Trans. Inform. Theory, vol. 47, no.11, pp. 2711-2736, Nov. 2001.

Analysis and Design of Experiments. H B Mann, DoverNew YorkH. B. Mann, Analysis and Design of Experiments. New York: Dover, 1949

Combinatorics of Experimental Design. A P Street, D J Street, Clarendon PressOxford, UKA. P. Street and D. J. Street, Combinatorics of Experimental Design. Oxford, UK: Clarendon Press, 1987.

On algebraic construction of Gallager and circulant low density parity-check codes. H Tang, J Xu, Y Kou, S Lin, K Abdel-Ghaffar, IEEE Trans. Inform. Theory. 506H. Tang, J. Xu, Y. Kou, S. Lin, and K. Abdel-Ghaffar, " On algebraic construction of Gallager and circulant low density parity-check codes," IEEE Trans. Inform. Theory, vol. 50, no.6 , pp. 1269-1279, June 2004.

Near Shannon limit quasicyclic low-density parity-check codes. L Chen, J Xu, I Djurdjevic, S Lin, IEEE Trans. Commun. 527L. Chen, J. Xu, I. Djurdjevic, and S. Lin, " Near Shannon limit quasi- cyclic low-density parity-check codes," IEEE Trans. Commun., vol. 52, no. 7, pp. 1038-1042, July 2004.

Codes on finite geometries. H Tang, J Xu, S Lin, K A S Abdel-Ghaffar, IEEE Trans. Inform. Theory. 512H. Tang, J. Xu, S. Lin, and K. A. S. Abdel-Ghaffar, " Codes on finite geometries," IEEE Trans. Inform. Theory, vol. 51, no. 2, pp. 572-596, Feb. 2005.

Algebraic construction of quasi-cyclic LDPC codes for the AWGN and erasure channels. Y Y Tai, L Lan, L Zeng, S Lin, K Abdel-Ghaffar, IEEE Trans. Commun. to appearY. Y. Tai, L. Lan, L. Zeng, S. Lin, and K. Abdel-Ghaffar, "Algebraic construction of quasi-cyclic LDPC codes for the AWGN and erasure channels," IEEE Trans. Commun., to appear.

Construction of regular and irregular LDPC codes: geometry decomposition and masking. J Xu, L Chen, I Djurdjevic, S Lin, K Abdel-Ghaffar, submitted to IEEE Trans. Inform. Theory in. in revisionJ. Xu, L. Chen, I. Djurdjevic, S. Lin, and K. Abdel-Ghaffar, "Construc- tion of regular and irregular LDPC codes: geometry decomposition and masking," submitted to IEEE Trans. Inform. Theory in 2004 (in revision).

A modified weighted bitflipping decoding of low-density parity-check codes. Juntan Zhang, P C Marc, Fossorier, IEEE Commun. Letters. 83Juntan Zhang and Marc P. C. Fossorier, "A modified weighted bit- flipping decoding of low-density parity-check codes," IEEE Commun. Letters, vol. 8, no. 3, March 2004

A decoding algorithm for finitegeometry LDPC codes. Zhenyu Liu, Dimitris A Pados, IEEE Trans. on Commun. 533Zhenyu Liu and Dimitris A. Pados, " A decoding algorithm for finite- geometry LDPC codes," IEEE Trans. on Commun. , vol. 53, no. 3, March 2005

An improvement on the modified weighted bit flipping decoding algorithm for LDPC codes. Ming Jiang, Chunming Zhao, Zhihua Shi, Yu Chen, IEEE Commun. Letters. 99Ming Jiang, Chunming Zhao, Zhihua Shi, and Yu Chen, "An improve- ment on the modified weighted bit flipping decoding algorithm for LDPC codes," IEEE Commun. Letters, vol.9, no. 9, Sept. 2005

Construction of low-density parity-check codes based on Reed-Solomon codes with two information symbols. I Djurdjevic, J Xu, K Abdel-Ghaffar, S Lin, IEEE Commun. Lett. 87I. Djurdjevic, J. Xu, K. Abdel-Ghaffar, and S. Lin, "Construction of low-density parity-check codes based on Reed-Solomon codes with two information symbols," IEEE Commun. Lett., vol. 8, no. 7, pp. 317-319, July 2004.

Efficient encoding of quasi-cyclic low-density parity-check codes. Z. -W Li, L Chen, L. -Q Zeng, S Lin, W Fong, IEEE Trans. Commun. 541Z. -W. Li, L. Chen, L. -Q. Zeng, S. Lin, and W. Fong, "Efficient encoding of quasi-cyclic low-density parity-check codes," IEEE Trans. Commun., vol.54, no. 1, pp. 71-81, Jan. 2006.

Polynomial codes over certain fields. I S Reed, G Solomon, J. Soc. Ind. Appl. Math. 8I. S. Reed and G. Solomon,"Polynomial codes over certain fields," J. Soc. Ind. Appl. Math., 8: 300-304, Jun. 1960.

Construction of quasi-cyclic LDPC codes for AWGN and binary erasure channels: a finite field approach. L Lan, L. -Q Zeng, Y Y Tai, L Chen, S Lin, K Abdel-Ghaffar, IEEE Trans. Inform. Theory. in revisionL. Lan, L. -Q Zeng, Y. Y. Tai, L. Chen, S. Lin, and K. Abdel- Ghaffar,"Construction of quasi-cyclic LDPC codes for AWGN and binary erasure channels: a finite field approach," IEEE Trans. Inform. Theory, in revision, 2006.

A trellisbased method for removing cycles for bipartite graphs and construction of low density parity check codes. L Lan, Y Y Tai, L Chen, S Lin, K Abdel-Ghaffar, IEEE Commun. Lett. 87L. Lan, Y. Y. Tai, L. Chen, S. Lin, and K. Abdel-Ghaffar,"A trellis- based method for removing cycles for bipartite graphs and construction of low density parity check codes," IEEE Commun. Lett., vol. 8, no. 7, pp. 443-445, Jul. 2004.

Regular and irregular progressive edge-growth Tanner graphs. X. -Y Hu, E Eleftheriou, D M Arnold, IEEE Trans. Inform. Theory. 511X. -Y. Hu, E. Eleftheriou, and D. M. Arnold,"Regular and irregular progressive edge-growth Tanner graphs," IEEE Trans. Inform. Theory, vol 51, no.1, pp. 386-398, Jan. 2005.