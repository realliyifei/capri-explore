# A Survey on RISC-V Security: Hardware and Architecture

CorpusID: 235790512 - [https://www.semanticscholar.org/paper/2e50675439a2bf21e5f2b80be26af4b66d2d8fce](https://www.semanticscholar.org/paper/2e50675439a2bf21e5f2b80be26af4b66d2d8fce)

Fields: Engineering, Computer Science

## (s3) The Root of Trust and the Hardware Security Module
(p3.0) The root of trust (RoT) [123] is the foundation on which all secure operations of computing systems depend.It contains keys for encryption functions, supports trusted boot and TEE.RoT is also important for public key infrastructure (PKI), which is used to generate and protect root and certificate authority keys, sign code for software security, immutability and authenticity, and create digital certificates for identity verification.Because the security of the system relies on the keys used to encrypt and decrypt data, as well as digital signatures and signature verification functions, the RoT is the always trusted source in the encryption system.RoT can secure data and applications and help build the chain of trust in the entire ecosystem.

(p3.1) The RoT must be secure by design.The hardware-based RoT will not be attacked by malicious software, so it is the most secure.The RoT can be an independent security module or a security module in a system-on-chip (SoC).A fixed-function RoT is a state machine designed to perform a specific set of operations, such as data encryption, certificate verification, and key management.Usually these functions are static and can only perform their specially designed functions.In addition, there is a kind of programmable RoT.It is built around the CPU, can perform more complicated security functions, can be upgraded, and can run new encryption algorithms and security applications to counter evolving attack vectors.

(p3.2) Since the RoT is the target of attackers, it is usually executed in isolation to ensure that sensitive security functions are executed in a dedicated security domain physically separated from the general-purpose processor.Safely isolating security functions in a physically separated RoT can reduce architecture complexity and optimize CPU performance.The RoT shall also have comprehensive anti-tampering and side-channel resistance capabilities, prevent fault injection and side-channel attacks, and support layered security to provide multiple layers of strong defense.For hardware-based roots of trust [124], encryption engines, keys, and other sensitive security resources can only be accessed in hardware.Based on the hardware RoT, software security mechanisms can be implemented to provide additional flexibility.

(p3.3) RoT solutions usually include a hardened hardware security module (HSM) that generates and protects keys and performs encryption functions in its secure environment [125].HSM is a tamper-proof hardware device that can enhance system security.The HSM is usually used for platforms with high data security and trust, which is inaccessible outside the system, so the system can trust the authentic and authorized keys and other encrypted information received from the HSM.The HSM can pass various FIPS certifications to prove its security specifications.The implementation of the HSM and the RoT is complicated, involving hardware and architecture, including system permission level control, secure memory access, password instructions, random number generators, etc.As shown in Figure 2, the RoT or HSM usually includes the following main components:
## (s4) Building Blocks of RISC-V Architecture Security
(p4.0) 2.3.1 RISC-V Architecture Stacks and Privilege Modes.RISC-V can support different software stack implementations.A simple system can be a bare-metal application running on an application execution environment (AEE) in the machine mode (M-mode).The application runtime interacts with a particular application binary interface (ABI), which includes the supported user-level ISA and a set of ABI calls to interact with the AEE.The ABI hides details of the AEE from the application, providing an abstract layer for flexibility of implementing the AEE.RISC-V can also run an operating system (OS) that can support multiple applications.Each application communicates over an ABI with the OS, which provides the AEE.RISC-V operating systems interface with a supervisor execution environment (SEE) via a supervisor binary interface (SBI).An SBI comprises the user-level  and supervisor-level ISA together with a set of SBI function calls.Using a single SBI across all SEE implementations allows a single OS binary image to run on any SEE.The SEE can be a simple bootloader and BIOS-style IO system on a low-end hardware platform, or a virtual machine in a high-end server, or a thin translation layer over a host operating system in an architecture simulation environment [52].

(p4.1) As Figure 3 shows, RISC-V can run a virtual machine monitor configuration where multiple OSs are supported by a hypervisor.This is a typical deployment in complicated infrastructure as a service scenarios.Each OS communicates via an SBI with the hypervisor, which provides the SEE.The hypervisor communicates with the hypervisor execution environment (HEE) using a hypervisor binary interface (HBI) to isolate the hypervisor from the hardware platform.

(p4.2) At any time, a RISC-V hardware thread (hart) is running at some privilege level encoded as a mode.Three RISC-V privilege levels are currently defined: User(U) mode (level 0), Supervisor(S) mode (level 1), and Machine(M) mode (level 3) [52].There was a level 2 H-mode defined in the RISC-V privileged architecture.H-mode was removed in version 1.10 to enable recursive virtualization support in S-mode.For backward compatibility, the latest RISC-V specification reserves the H-mode.In summary:

(p4.3) • The privilege level is used to provide differentiated protection for different components of the software stack, which lays the foundation for the security of the RISC-V platform.• M-mode is the highest privilege level.It is the only mandatory privilege level of the RISC-V hardware platform.Code running in M mode is usually inherently trustworthy because it has low-level access to the machine implementation.M-mode can be used to manage the secure execution environment on RISC-V.• Many RISC-V implementations support U-mode to protect the rest of the system from application code.
## (s12) Program
(p12.0) Obfuscator and Churn Units.It is challenging to implement virtual black box (VBB) obfuscation of general programs in a pure software manner.Nayak et al. [85] proposed HOP, which uses secure hardware to realize the simulated security obfuscation of RAM programs.HOP only trusts the hardware processor.The theoretical analysis of HOP considers all the optimizations used in the actual design, including the use of hardware Oblivious RAM (ORAM), hardware scratchpad, instruction scheduling technology, and context switching.They introduced the FPGA prototype hardware implementation of HOP.Through various benchmark evaluations, the cost of HOP is 8 to 76 times that of an insecure system.Compared with all previous efforts to achieve obfuscation (unimplemented), HOP has improved performance by more than three orders of magnitude, making obfuscation technology one major step closer to achieving the goal of being deployable in practice.

(p12.1) Constantly obfuscating the information required by the attacker is an effective counter-attack method.Frequent obfuscation will produce high system overhead.Gallagher et al. [163] proposed Morpheus, which is an ensemble of mobile target defense with a hardware churn unit, in which each mobile target defense uses hardware support to provide more randomness at a lower cost.When used in conjunction with obfuscation, Morpheus defense can provide powerful protection against control flow attacks.Security testing and performance research show that Morpheus has achieved high coverage protection against various control flow attacks, including protection against advanced attacks.In addition, a churning period of up to 50 milliseconds is at least 5000 times faster than the time required to penetrate Morpheus.
## (s13) Memory Protection.
(p13.0) Code injection and code reuse attacks such as buffer overflow and return-oriented programming (ROP) are still threats to RISC-V programs.De et al. [65] proposed two hardware security extensions for RISC-V.First, they use a physical unclonable function (PUF)-based random canary generation technology, which eliminates the need to store sensitive canary words in memory or CPU registers, so it is more secure and efficient.They implemented the proposed Canary engine in RISC-V Rocket Chip.The simulation results show that for a single buffer protection, the average execution overhead is 2.2%.When the protection is extended to all buffers, increasing the buffer count by 10 times will only increase the overhead by 1.5 times.Second, the author implements Fixer, a dedicated security coprocessor extension for flow integrity.FIXER enforces fine-grained control flow integrity (CFI) for programs running on the backward edge (return) and forward edge (call) without requiring any architectural changes to the processor core.Compared with software-based solutions, FIXER reduces energy consumption by 60% with minimal execution time (1.5%) and area (2.9%) overhead.
## (s24) Lightweight Cryptography
(p24.0) First, small IoT devices require lightweight cryptographic algorithms.It is common that small IoT devices are CPU or memory resource-constrained, they may not be powerful enough to support efficient execution of standard cryptographic algorithms.As Table 3 shows, the latest Polarfire RISC-V FPGA has an average single-core compute performance of only 3.1% of the Intel Xeon 4215 x86 processor.Lightweight cryptography has been proposed to meet the requirements of resource constrained devices [97].Lightweight conceptually can refer to chip area size, code/memory size, energy efficiency, etc.There is an ISO/IEC 29192 standard for lightweight block ciphers.CLEFIA [178], PRESENT [179], LEA [180] are three of the ISO block cipher algorithms.

(p24.1) NIST is also screening lightweight cryptography algorithms, which will be included into the NIST lightweight cryptographic standard.A major challenge of applying encryption in restricted environments is the trade-off between security and performance.Fabio et al. [97] analyze different strategies for optimizing candidate solutions of the NIST lightweight cryptographic algorithms on the RISC-V architecture.Specifically, they demonstrated how multiple lightweight NIST candidates such as Gimli, Sparkle, Saturnin, Ascon, Delirium, and Xoodyak can be efficiently implemented.They studied the overall impact of optimizing symmetric key algorithms in assembly and C languages, proposing optimizations such as loop unrolling that can speed up the software-implemented algorithms by up to 81%.
## (s25) Symmetric and Asymmetric Cryptography
(p25.0) Stoffelen et al. [98] highlight the features of RISC-V, and provide optimized assembly implementation of tablebased AES, bit-sliced AES, ChaCha and Keccak-f[1600] for the RV32I instruction set.Regarding public key cryptography, they study the performance of arbitrary-precision integer arithmetic without the carry flag.They conduct quantitative performance studies on several RISC-V extensions, which provide design insights for future RISC-V core design and implementation.Fixed function hardware accelerators such as an AES engine cannot support new ciphers.Kiningham et al. [88] introduce Falcon, a hardware architecture used to accelerate various ciphers on energy-constrained devices.Falcon provides a general execution engine that support bitslice and permutation instructions, which are the backbone operations of current and probably future dominant ciphers including AES, Cha-Cha, SHA-256, RSA, Curve25519 ECC, and post-quantum cryptography such as R-LWE.For encryption technology, Falcon provides software flexibility while reducing the energy consumption of ciphers by 5 to 60× compared with software implementations.This improvement makes it feasible for IoT applications to upgrade the ciphers after deployment, so that they can always stay abreast of the latest security practices without shortening device deployment life or sacrificing application workload.

(p25.1) To deal with the security challenges of IoT devices, Loiseau et al. [91] propose a fast, low-power encryption technology for a new set of Binary Edwards Curves that have been defined to reach up to 284-bit security level suitable for IoT devices embedded with 32-bit general-purpose processors.They optimized the choice of point generators using w coordinates to save multiplication in addition and doubling formulas.They managed to calculate one step of the Montgomery ladder with 4 multiplications and 4 squares.In addition to performance advantages, encryption on this curve also has inherent security properties against physical attacks.
## (s27) TRNG
(p27.0) As we have discussed in Section 2.2, the random number generator is an important root of trust module.Saarinen et al. [87] propose RISC-V true random number generator (TRNG) architecture that separates the entropy source component and the encrypted PRNG into a single interface.This is different from the previous TRNG implementations.They describe the interface and its use in cryptography, and discuss the background and basic principles of the interface.The design refers to the mainstream ISA, the latest SP 800-90B and FIPS 140-3 entropy review requirements, AIS-31 and Common Criteria for IT Security Evaluation, as well as current and emerging encryption requirements such as post-quantum encryption.The architecture choice is the result of quantitative observations on secure microcontrollers, Linux kernels and random number generators in cryptographic libraries.They further compare this architecture with some contemporary random number generators and describe a minimal TRNG reference implementation using an entropy source and RISC-V AES instructions.
## (s28) DICE
(p28.0) The Device Identifier Composition Engine (DICE) is the minimal requirement for trusted computing on microcontrollers.Currently, most implementations use hardware that is not specifically designed for this purpose.These implementations rely on black-box MPUs.Because hardware that is not originally designed for DICE is used, there are certain pitfalls in the implementation process.Jager et al. [90] propose a DICE architecture based on a microcontroller, which is equipped with hardware that meets DICE requirements.It includes minor modifications to the processor pipeline, dedicated memory blocks, and modified interrupt and debug modules.They create an FPGA prototype based on the VexRiscV platform and evaluate the impact of the increase in chip size and DICE extension on the runtime to prove that DICE can be implemented with minimal changes to the microcontroller design and used in IoT and automotive environments as a trusted component.
## (s30) Branch Prediction Vulnerabilities
(p30.0) The side-channel vulnerabilities of modern processors make hardware security a top priority in processor design.Gonzalez et al. [100] demonstrated how a general-purpose open source Berkeley Out-of-Order Machine (BOOM) based on a RISC-V processor can be used to research mitigating side-channel attacks at the microarchitecture level.First, they replicate several basic variants of the Spectre vulnerability [21], which utilize speculative execution in the L1 data cache.Then, they implement preliminary hardware mitigation measures against this type of attack, prove its effectiveness, and measure its impact on performance and area size.Compared with the baseline processor, evaluation of the hardware mitigation shows that in the 45nm process, the IPC has increased by 2%, the area has increased by 2.5%, and the clock has been reduced by 0.36%.This work confirms the value of the open source RISC-V hardware ecosystem for secure hardware research.
## (s31) Power and Electromagnetic Analysis Attacks
(p31.0) Running unprotected software on an unprotected microprocessor can cause various side-channel leakages including direct-value leakage, data-overwrite, and circuit-level leakage [103].The software implementation of cryptographic algorithms is vulnerable to side-channel analysis (SCA) attacks because the cryptographic key may leak through the processor's measurable physical characteristics such as power consumption and electromagnetic radiation.Various algorithms with solutions have been proposed to mitigate this issue.However, they rely on equipment assumptions that are rarely met, thus are not easy to implement.Moreover, these solutions do not consider microarchitecture-related issues.Mulder et al. [103] propose integrating the countermeasures of side-channel analysis into the RISC-V implementation.They use masking technology to wrap the secret before writing it to memory and do a reverse operation to unwrap the secret after reading it back from memory, so as to protect memory access from SCA.The solution prevents first-order power or electromagnetic attacks while keeping the implementation cost as low as possible.The evaluation results confirm the security of various encryption primitives running on the protected hardware platform.
## (s32) Timing Attack
(p32.0) The calculation of algorithms takes time.If the algorithm is not carefully designed with constant execution time, it may cause different inputs to have different execution times.If the calculation involves sensitive information such as a cryptographic key, the attacker may reverse the content of the key by traversing a large number of input vectors and accurately measuring the execution time of each test vector, causing the leakage of sensitive information.Prying sensitive key data through time information is usually much easier than cryptanalysis using known pairs of plaintext and ciphertext.

(p32.1) The Translation Lookaside Buffers (TLBs) in modern processors may cause timing side-channel attacks.But exploiting the TLB channel is challenging due to unknown addressing functions inside the TLB and the attacker's limited monitoring capabilities that at best cover only the victim's coarse-grained data accesses.However, recently researchers can reverse engineer the addressing functions inside the TLB, and devise a machine learning strategy that exploits high-resolution temporal features about a victim's memory activity, which make TLB side-channel attack practical [188].To mitigate this risk, Deng et al. [99] introduce a novel three-step modeling method that is used to exhaustively enumerate all possible TLB-based timing vulnerabilities.Step 1 performs memory operations and places the TLB block in a known initial state.Then, step 2 performs the second memory operation to change the state of the TLB block.Finally, Step 3 performs the final memory operation, and the time of the final operation depends on the addresses of Step 1, Step 2 and Step 3. Attacks with more than three steps can be broken down into a three-step attack.Based on the three-step model, they show how to automatically generate a micro-security benchmark that can test TLB vulnerabilities.They propose two new secure TLB designs: static partition (SP) TLB and random fill (RF) TLB.The evaluation of the secure TLB implemented in RISC-V Rocket Core shows that the new TLB can not only defend against previously announced attacks, but also against other new timing-based attacks in the TLB discovered using the new three-step model.The FPGA-based evaluation shows that the RF TLB defends against all attacks with performance overhead of less than 10%.

(p32.2) Multi-processor system-on-chip (MPSoC) is a popular computing platform suitable for various applications due to its energy efficiency and flexibility.SoCs with heterogeneous architecture allow for the integration of various central processing units and even graphics processors on the same system are getting popular [189].Like many other platforms, they are also vulnerable to side channel attacks (SCA).Logical SCA can retrieve sensitive information by simply observing the system attributes that depend on the software executed by the victim on the MPSoC, which is very harmful.Unfortunately, many current protection mechanisms are either platform-dependent or only effective against a few attacks.Reinbrecht [102] introduces Guard-NoC, which is a secure network-on-chip (NoC) architecture that can protect MPSoC from various Logical SCAs.The secure NoC uses three application-independent strategies to hide and isolate sensitive information by masking the execution time of the operation and employing dual communication strategy such as using packet and circuit switching at the same time.Packet switching is used for secure packets and circuit switching is used for common packets.Evaluation shows that the security NoC can resist the actual Logical SCAs, and hardly leak any information, while having a minimal area size and power consumption.

(p32.3) Timing side channel attacks are an important issue in cryptographic algorithms.If the execution time of the implementation depends on secret information, the adversary can infer the secret by measuring the execution time.Different methods have recently emerged to explore information leaks in encryption implementations and protect them from these attacks.For example, in Section 3.1 we have discussed IODINE [64], which translates Verilog code for a formal analysis to detect timing channels.However, there is very little about ISA emulation and its impact on timing attacks.Napoli et al. [101] studied the impact of OI-DBT, a dynamic binary translator using different region formation technologies (RFT), on the implementation of constant time and non-constant time of cryptographic algorithms.Experiments show that simulation can have a significant impact on secret leakage, and even mitigate leakage in some cases.In addition, the results show that the simulator's choice of RFT heuristic also has an impact on these leakages.

(p32.4) In Section 3.2, we have discussed program obfuscation as a widely used intellectual property (IP) protection technique against reverse engineering attacks.Biswas et al. [190] observed that the choice of transformation sequence has a significant impact on timing channel information leakage.Certain transformation sequences may cause leakage higher than the original program.Biswas et al. proposed a timing channel sensitive program obfuscation optimization framework based on the genetic algorithm to find the best combination of obfuscation transformation functions in terms of performance and prevention of timing side channel leakage.They evaluated the new framework on the RISC-V Rocket core.They use the dudect tool to verify that the proposed TSC-SPOOF framework provides optimization points for ModExp and MulMod16 programs, while reducing timing channel leakage.They observed that for the optimized ModExp and MulMod16 programs, it takes about 1M and 2M measurements, respectively, to pass through the t-statistic of 10.But for the two programs in the initial population, only 20K measurements are needed to cross the same t-statistic.
