# Distributed Software Evolution: a Survey

CorpusID: 248476228 - [https://www.semanticscholar.org/paper/56865c079e1aae543654686ac628c524f5d07475](https://www.semanticscholar.org/paper/56865c079e1aae543654686ac628c524f5d07475)

Fields: Computer Science

## (s4) Open-Source Software
(p4.0) It can be concluded that this paper and other similar papers addressed the concern for distribution as a characteristic for software evolution. In other words, the systems that use a kind of distribution in their processes have a specific feature (i.e., distribution), based on which their components and processes should be configured.

(p4.1) Ref. [19] worked on the anti-patterns and defects of open-source software development such as the defect or lack of documents, inconsistency of components, lack of coordination between developers, lack of communication between developers, lack of qualitative review of software products and its low quality, insufficient information about the team status, insufficient information about the project status among the involved individuals, lack of reporting and getting feedback from users, and failure to use their experience for the constant software improvement. This paper proposed a method for eliminating anti-patterns and defects. For this purpose, the necessary knowledge about the status and background of a software project should first be provided in a knowledge repository to enable the project manager to find a solution to the elimination of anti-patterns and defects. In the proposed method, a CVS ontology and a bug ontology are developed to determine the data structures that should be stored in the knowledge repository within the development process. An important aspect of projects based on Open Architecture is the software license, which can change over time. There are different types of licenses that might change many times during the software lifecycle.

(p4.2) This can be a research topic (Ref. [32]). In FLOSS projects, a problem is that some tasks are popular with participants, whereas some other tasks are not. This problem is known as the "popularity phenomenon" in this field (Ref. [33]). This kind of evolution and development process in FLOSS projects may lead to an unbalanced growth. For instance, the bugs of a specific component might be eliminated very quickly; therefore, it will be practically reliable and high-quality. However, the bugs of another component in the same system might be eliminated after a long time. Hence, the bugs are either not detected on time or left undeleted for a long time after they are detected. As a result, that component is practically unreliable and will have low quality.

(p4.3) Another problem with open-source projects is that the system architecture sometimes emerges after the system is developed instead of being designed in advance. This is a characteristic of complex systems. In other words, the next system status cannot be predicted nearly accurately. In fact, the next system status emerges in practice, something which indicates the process of evolution in open-source projects and the participants are practically the components of a complexity and a complex system. The next complexity emerges from their interaction. However, if the Open Architecture is used, such an incident should not occur seriously. In this case, the high-level architecture layer should direct the entire evolutionary process of the system.
## (s6) Tools, Requisites, Outcomes, and Challenges
(p6.0) Ref. [6] (2010) proposed a tool for the analysis of the distributed software evolution. According to this paper, collaborative frameworks and compatibility with collaboration will not only enable software developers to create applications in distributed teams but also help analysists work in (geographically) distributed frameworks to analyze the software evolution procedure. Such a tool will particularly be very efficient in open-source projects; hence, its user interface is Web-based and can be accessed at http://churrasco.inf.unisi.ch. This tool visualizes the analysis results in different formats (e.g., a radar chart or a polymetric view).

(p6.1) An approach to the development process is to see it as a business process by considering a number of activities performed by a few individuals. It is possible to defined an order, a condition, a priority, a delay, and parallelism for these activities. Business processes can be modeled on activity networks (or other process modeling languages). A modeling process can also be executed.

(p6.2) The development process support systems use something similar to an activity network to model the development process and then execute the model. However, what does a development process mean? It should be mentioned that the steps of a development process are usually taken by the project stakeholders and developers. When an activity is performed by someone, the process support system will be notified. Based on the process model and the current project status, the process support system determines the next process step and notifies those who should take the next step.

(p6.3) A coordinate of complex development processes (in addition to other coordinates such as the dynamism of changes in the development process, necessity of reusing products and objects, etc.) is the distribution of a process. In other words, the individuals and sub-processes gathered together in a general process should be able to interact within a distributed framework (in terms of time, location, etc.) to progress the software development process.

(p6.4) At the same time as the software evolution, the software development process should be completed in order to reflect the changes occurring along the software evolution in terms of dimension, complexity, domain, purpose, and other characteristics of a software application.
