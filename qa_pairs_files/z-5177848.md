# DETECTING CODE CLONES: A REVIEW 1 Detecting Code Clones: A review Informatics Research Review (IRR) University Of Edinburgh

CorpusID: 5177848 - [https://www.semanticscholar.org/paper/68ebe85f94ff5bfa1914608f0d0204d0d43448f0](https://www.semanticscholar.org/paper/68ebe85f94ff5bfa1914608f0d0204d0d43448f0)

Fields: Computer Science

## (s0) Introduction
(p0.0) Duplication of code occurs when a software programmer copies a portion of working code to another location either within the same code base or to another code base. Usually these code fragments are edited slightly to fit the use case in the new location. As duplication is not included in the documentation of the application, this can lead to complications when managing the software; especially when the copied code contains bugs within itself. Hence, when such a code fragment needs to be edited, usually for the sake of bug fixing or to implement an update, all duplicates of that code will require a corresponding adjustment to prevent bugs and inconsistencies in the final application. For such a maintenance operation to be complete, all the copies of the code fragment need to be identified prior to modification. In a large code base, this becomes nearly impossible to achieve manually. Code clone detection algorithms and tools have been developed to tackle this challenge. Recent software development platforms have a refactorisation feature which does a top level editing. However, this is not sufficient for detecting or editing code clones especially when portions of the clones have been modified.

(p0.1) Defining what constitutes a code clone may be difficult, but generally speaking, code clones are those duplicates in a code base that pose copy-paste problems as defined above. Hence, programming language constructs, idioms and other such recurring statements should not normally be considered as duplicated code, since they do not pose such copyand-paste problems [7]. Many code detection approaches require parsing of the source code and using a pattern recognition or data mining technique to fetch the clones.
## (s3) Types of code clones
(p3.0) The types of clones can be grouped into 3 [3][21]: Type 1 clones (Exact clones) -where a clone is a clear copy of a code fragment with very minor editions such as deletion of white space or addition of comments. Type 2 clones (Parameterised clones) -where the cloned code is modified by changing variable and method names, usually in an attempt to mask it from detection or to make it better fitted for its destination. Code fragments such as "sum = sum + 5" and "total = total + 5" are considered as Type 2 clones. Type 3 clones(Gapped clones) -where whole statements are deleted or relocated within the clone. These are the hardest to detect.
## (s4) Challenges facing code clone detection
(p4.0) Code clone detection is akin to searching for people with the same features in a population. The search space is in an order of O(n 2 ) [6] where n is the number of lines in the source code after pre-processing. It is obvious that manual method of identifying clones in a code base becomes inefficient as the code base grows. A good clone detection tool must be able to cope with large code bases. This is called scalability. While automating the process of detection, Questions like "How similar should two code fragments be to be declared clones?" are not uncommon. A useful detection tool must have a clear definition of its basis for declaring clone candidates. This definition is not fixed and it varies from application to application depending on the judgement of the researcher. Unfortunately, this affects the quality of the clone candidates.

(p4.1) Also, the compromise required between recall and precision poses a challenge. As explained by Ducasse et al.,using the notation in Figure 1, if a detection tool presents C code fragments as candidate clones, we aim to bring C as close as possible to the actual clones A, contained in the code base. If D is the set of code fragments in C that are accepted as actual clones, then Figure 1 defines Recall and Precision. The problem of recall and precision is a problem of false positives and false negatives. False positives occur when the detection tool wrongly labels code fragments as clones. This negatively impacts precision. Similarly, false negatives occur when the detection tool fails to identify actual clones as clones. This will occur if the programmer is sufficiently experienced and is able to modify the code sufficiently to mask the clones. This affects recall. Over these parameters, we seek a system that shows a good level of recall as well as precision. Unfortunately, techniques that have high recall (detect many clones) return many false positives (lower precision). The converse is also true. However, many times the compromise between precision and recall is biased towards recall.

(p4.2) Finally, code clone detection is heavily dependent on the specific language and dialect. Thus, such a tool created for one language may require an expert technologist to adapt for detection in source code written in another language. This is especially true when a more advanced approach is used such as the tree based or semantics based approaches.
## (s5) General steps used in code clone detection
(p5.0) Clone detection usually involves three major steps. A pre-processing stage which takes away uninteresting content like comments and white space. Afterwards, the source code is transformed into a compatible format e.g strings, tokens, trees or even vectors. Then, a comparison algorithm is then applied to the resulting data [6].
## (s8) Conclusion
(p8.0) Although the real effect of code clones have been argued, there is no doubt that bug ridden code clones increases the time and cost implications of code maintenance operations. Comparisons of the tools developed so far, however difficult, shows that there is no tool or method with returns better results in all situations, although the researchers often claim so [20]. Although a fair compromise may be made, recall and precision are the key aims of every code clone detection tool. Type 1 and Type 2 clones have been detected with relative ease. However, a lot of work still needs to be done in detecting Type 3 clones.
