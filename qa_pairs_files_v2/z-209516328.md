# Logic Bugs in IoT Platforms and Systems: A Review

CorpusID: 209516328 - [https://www.semanticscholar.org/paper/18311137888a74119a38efde68a5c9eaa0e56a2c](https://www.semanticscholar.org/paper/18311137888a74119a38efde68a5c9eaa0e56a2c)

Fields: Computer Science, Engineering

## (s6) Bug 3: Weak Owner Authentication
(p6.0) A. System model. Some IoT device manufacturers do not deploy their devices with IoT platform, so that they have to adopt other protocols like Nimble out-of-band authentication for Extensible Authentication Protocol (EAP-NOOB) to implement bootstrapping of new devices.

(p6.1) For EAP-NOOB protocol, a human-assisted-out-of-bind (OOB) channel is added to achieve device binding process. Specifically, When a user wants to bind the device, he first needs to deliver his user authentication message to the device in an OOB channel. The form of user authentication message could be QR code, audio signal, NFC data, etc. Then the device transmits user authentication message to the cloud with its identity information, finally the cloud can bind this device with the user's account. For example, when the user binds the camera, the IoT cloud will generate a QR code associated with his account and send it to user's mobile app. Then user should let the camera scan the QR code to complete the device binding process.

(p6.2) B. Attack Scenario. We show a specific attack scenario in Figure 3. The user first resets the device to activate the device registration. At the same time, the attacker also activates the registration of device B. After that, the user logs in his account and choose the camera A, and the QR code encoding as authentication message are generated from the cloud. Then, the user shows the QR code to the camera A (in the OOB channel indicated by the dashed line in Figure 3). Since the device A is compromised and controlled, the attacker would deliver the message received by the device A to another device B. With the authentication message, the attacker successfully binds the cameras B to the user's account. As a result, the devices B owns authentication message and would be successfully associated with the user's account on the IoT cloud which is against the user's intention. The researchers [18] call this attack as misbinding attack.

(p6.3) C. Cause Analysis. In the IoT device bootstrapping process, the IoT cloud lacks adequate authentication of target IoT device which causes this logic bug. Specifically, the IoT cloud associates the user's account with the IoT device which provides the user's authentication message generated by the mobile app. Once the target IoT device is compromised, the information could be stole by the attacker and used for another device binding. In addition, IoT devices take user's physical access to devices as their identities instead of cryptographically verifiable identities such as serial number, public keys, which makes it hard for the IoT cloud to authenticate the IoT device.

(p6.4) D. Identifying Method. To analysis a authentication protocol whether this logic bug exists or not in it, Sethi et al. [18] have proposed a formal model analysis approach based on an automatic cryptographic protocol verifier named Proverif. This analysis approach finally finds two forms of misbinding. One is shown in the attack scenario, and another is that both devices are compromised and the bug could be exploited similarly.

(p6.5) E. Defense. Approaches such as identifier communication and presence checking have been proposed by Sethi et al. [18] to partially defense the attacks. In the identifier communication approach, the IoT cloud utilizes some printable information such as model, serial numbers and even public-key fingerprint attached to the device for enhancing device authentication. Thus, it would be more difficult for attackers to launch the misbinding attack. In the presence checking approach, the user always communicates with the dynamic root of trust for measurement (DRTM) inside the device and generates authentication approaches based on trust computing base (TCB), which could check the presence of the device correctly even with untrusted software in the IoT device.
## (s22) UNEXPECTED TRIGGER ACTION IN AUTOMATION APPLICATION 8.1 System Model
(p22.0) The automation app developments are based on a software stack provided by IoT platforms to realize monitoring and controlling on IoT devices * . Under the hood, as shown in Figure 10, the triggeraction model of the IoT platform consists of events, event-handler methods of automation app, actions, and the attributes which represent the state information of devices. To realize the trigger-action services, the automation app needs to register an event-handler with a device event or pre-defined event. The handlers are triggered to take action when these events occur. Actions represent the commands to control device states, which cause modifications on attributes, e.g., device state changes.

(p22.1) By exploiting the logic flows of the trigger-action rules, several critical bugs have been disclosed by Celik et al. [5], In what follows, we introduce four representative bugs in this category.
## (s23) Bug 11: Race Conditions of Events
(p23.0) A. Attack Scenario. As is defined in [5], an attribute of a device can not be modified to conflicting values by two or more noncomplementary event handlers of multiple apps working in concert, which may lead to a potential race condition. For example, "When motion is detected, turn on the switch" and "Every day at midnight, turn off the switch" will conflict if motion is detected at 12 pm. It is notable that the authors [5] do not investigate what attacks the adversary may realize by utilizing these bugs. Thus, the consequences caused by this bug are limited to leading devices trapped into insecure or unsafe states. * All the unexpected trigger-action bugs covered in this section lie in Samsung's Smart-Things Platform B. Cause Analysis. Upon its subscribed events' occurrence which is different from each other, two or more independent event-handlers of multiple apps are invoked to take actions possibly at the same time to manipulate the same attribute of one device to conflicting values. The sequence and timing of actions of these event-handlers usually make the final states of devices unpredictable.
